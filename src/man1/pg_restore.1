.\" auto-generated by docbook2man-spec $Revision: 1.1 $
.TH "PG_RESTORE" "1" "2003-11-02" "Application" "PostgreSQL Client Applications"
.SH NAME
pg_restore \- 从一个由 pg_dump 创建的备份文件中恢复 PostgreSQL 数据库。

.SH SYNOPSIS
.sp
\fBpg_restore\fR\fR [ \fR\fB\fIoption\fB\fR...\fB \fR\fR]\fR\fR [ \fR\fB\fIfilename\fB \fR\fR]\fR
.SH "DESCRIPTION  描述"
.PP
\fBpg_restore\fR 是一种用于恢复由 \fBpg_dump\fR(1)  创建的任何非纯文本输出格式中的 PostgreSQL 数据库的应用。 它将发出必要的命令来重新构造数据库，以便于把它恢复成保存它的时候的样子。 归档（备份）文件还允许pg_restore 有选择地进行恢复， 甚至在恢复前重新排列条目的顺序。归档的文件设计成可以在不同的硬件体系之间移植。
.PP
\fBpg_restore\fR 可以以两种模式操作：如果声明了数据库名字， 那么归档是直接恢复到数据库里。大对象只能用直接数据库联接进行恢复。 否则，先创建一个包含重建数据库所必须的 SQL 命令的脚本（并且写入到一个文件或者标准输出）， 类似 pg_dump 输出纯文本格式的时候创建的那种脚本。 因此，一些控制脚本输出的选项就是摹拟 pg_dump 的操作。
.PP
显然，\fBpg_restore\fR 无法恢复那些不存在归档文件中的信息； 比如，如果归档是用"把数据转储为 INSERT命令"选项制作的， 那么 pg_restore 将不能使用 COPY 语句装载数据。
.SH "OPTIONS 选项"
.PP
\fBpg_restore\fR 接受下列命令行参数。
.TP
\fB\fIfilename\fB\fR
 声明要恢复的备份文件的位置。如果没有声明，则使用标准输入。
.TP
\fB-a\fR
.TP
\fB--data-only\fR
 只恢复数据，而不恢复表模式（数据定义）。
.TP
\fB-c\fR
.TP
\fB--clean\fR
 创建数据库对象前先清理（删除）它们。
.TP
\fB-C\fR
.TP
\fB--create\fR
 在恢复数据库之前先创建它。（如果出现了这个选项，和 \fB-d\fR  在一起的数据库名只是用于发出最初的 CREATE DATABASE 命令。 所有数据都恢复到名字出现在归档中的数据库中去。）
.TP
\fB-d \fIdbname\fB\fR
.TP
\fB--dbname=\fIdbname\fB\fR
 与数据库 dbname 联接并且直接恢复到该数据库中。
.TP
\fB-f \fIfilename\fB\fR
.TP
\fB--file=\fIfilename\fB\fR
 声明生成的脚本的输出文件，或者出现 \fB-l\fR 选项时用于列表的文件，缺省是标准输出。
.TP
\fB-F \fIformat\fB\fR
.TP
\fB--format=\fIformat\fB\fR
 声明备份文件的格式。因为pg_restore 会自动判断格式，所以如果声明了，它可以是下面之一：
.RS
.TP
\fBt\fR
 备份是一个 tar 归档。 使用这个格式允许在恢复数据库的时候重新排序和/或把表模式元素排除出去。 同时还可能在恢复的时候限制装载的数据。
.TP
\fBc\fR
 备份的格式是来自 pg_dump 的客户化格式。 这是最灵活的格式，因为它允许重新对数据排序，也允许重载表模式元素。 缺省时这个格式是压缩的。
.RE
.PP
.TP
\fB-i\fR
.TP
\fB--ignore-version\fR
 忽略数据库版本检查。
.TP
\fB-I \fIindex\fB\fR
.TP
\fB--index=\fIindex\fB\fR
 只恢复命名的索引。
.TP
\fB-l\fR
.TP
\fB--list\fR
 列出备份的内容。这个操作的输出可以用 -L 选项限制和重排所恢复的项目。
.TP
\fB-L \fIlist-file\fB\fR
.TP
\fB--use-list=\fIlist-file\fB\fR
 只恢复在 list-file 里面的元素，以它们在文件中出现的顺序。 你可以移动各个行并且也可以通过在行开头放 ';' 的方式注释。（见下文获取例子。）
.TP
\fB-N\fR
.TP
\fB--orig-order\fR
 以最初在 pg_dump 里生成的转储顺序恢复项目。 这个选项没有什么实际的用途，因为 pg_dump 会以自己方便的顺序生成项， 这个顺序不可能是恢复这些数据的安全顺序。 （这个顺序不是项最后在归档的内容列表中列出的顺序。） 又见 -r。
.TP
\fB-o\fR
.TP
\fB--oid-order\fR
 以 OID 顺序恢复项目。这个选项用处很小， 因为 OID 只是最初创建顺序的一个近似指示。 如果还声明了 -N，那么这个选项还覆盖它。又见 -r。
.TP
\fB-O\fR
.TP
\fB--no-owner\fR
 不要输出设置对象的权限，以便与最初的数据库匹配的命令。 缺省时，pg_restore 发出 \fBSET SESSION AUTHORIZATION\fR 语句设置创建出来的模式元素的所有者权限。 如果最初的数据库连接不是由超级用户（或者是拥有所有创建出来的对象的同一个用户）发起的，那么这些语句将失败。 使用 -O，那么任何用户都可以用于初始的连接，并且这个用户将拥有所有创建出来的对象。
.TP
\fB-P \fIfunction-name(argtype [, ...])\fB\fR
.TP
\fB--function=\fIfunction-name(argtype [, ...])\fB\fR
 只恢复指定的命名函数。请注意仔细拼写函数名及其参数，应该和转储的内容列表中的完全一样。
.TP
\fB-r\fR
.TP
\fB--rearrange\fR
 以对象类型重排项目（这个发生在以 -N 或者 -o 排序之后）。 重排是为了给出最大可能的性能。

如果没有 \fB-N\fR, \fB-o\fR, 和\fB-r\fR，那么 pg_restore 以项目出现在归档
的内容列表中的顺序恢复他们， 或者按照他们在 list-file 里面的顺序恢复他们
\(em 假如给出了 -L 的话。 -o 和 -r 的组合复制了 pg_dump 在创建归档的内容列表
之前进行的排序， 因此，这个选项通常没必要声明。
.TP
\fB-R\fR
.TP
\fB--no-reconnect\fR
 这个选项已经废弃了，但是为了保持向下兼容仍然接受。
.TP
\fB-s\fR
.TP
\fB--schema-only\fR
 只恢复表结构（数据定义）。不恢复数据，序列值将重置。
.TP
\fB-S \fIusername\fB\fR
.TP
\fB--superuser=\fIusername\fB\fR
 设置关闭触发器时声明超级用户的用户名。 只有在设置了 \fB--disable-triggers\fR 的时候才有用。
.TP
\fB-t \fItable\fB\fR
.TP
\fB--table=\fItable\fB\fR
 只恢复表指定的表的定义和/或数据。
.TP
\fB-T \fItrigger\fB\fR
.TP
\fB--trigger=\fItrigger\fB\fR
 只恢复指定的触发器。
.TP
\fB-v\fR
.TP
\fB--verbose\fR
 声明冗余模式。
.TP
\fB-x\fR
.TP
\fB--no-privileges\fR
.TP
\fB--no-acl\fR
 避免 ACL 的恢复（grant/revoke 命令）。
.TP
\fB-X use-set-session-authorization\fR
.TP
\fB--use-set-session-authorization\fR
 这个选项已经废弃了，但是出于向下兼容，仍然接受。 pg_restore 现在总是表现得像以前选中这个选项一样。
.TP
\fB-X disable-triggers\fR
.TP
\fB--disable-triggers\fR
 这个选项只有在执行仅恢复数据的时候才相关。它告诉 pg_restore  在装载数据的时候执行一些命令临时关闭在目标表上的触发器。 如果你在表上有完整性检查或者其它触发器， 而你又不希望在装载数据的时候激活它们，那么可以使用这个选项。

 目前，为 \fB--disable-triggers\fR 发出的命令必须以超级用户发出。 因此，你应该也要用 -S 声明一个超级用户名，或者更好是设置 \fB--use-set-session-authorization\fR 并且以 PostgreSQL  超级用户身份运行 pg_restore。
.PP
.PP
\fBpg_restore\fR 还接受下面的命令行参数做为联接参数：
.TP
\fB-h \fIhost\fB\fR
.TP
\fB--host=\fIhost\fB\fR
 声明服务器运行的机器的主机名。 如果数值以斜扛开头，那么它被用做 Unix 域套接字的目录。 缺省是从 PGHOST 环境变量中获取的（如果设置了）， 否则将尝试进行 Unix 域套接字。
.TP
\fB-p \fIport\fB\fR
.TP
\fB--port=\fIport\fB\fR
 声明服务器侦听的 TCP 端口或者本地的 Unix 域套接字文件扩展。 缺省是环境变量 PGPORT 的值（如果设置了的话）， 否则就说编译的缺省。
.TP
\fB-U \fIusername\fB\fR
 以给出用户身分联接。
.TP
\fB-W\fR
 强制给出口令提示。如果服务器要求口令认证，那么这个应该自动发生。
.PP
.SH "ENVIRONMENT 环境"
.TP
\fBPGHOST\fR
.TP
\fBPGPORT\fR
.TP
\fBPGUSER\fR
 缺省连接参数。
.SH "DIAGNOSTICS 诊断"
.PP
 当使用-d选项声明了直接数据库联接时， pg_restore 在内部执行 SQL 语句。如果你运行 pg_restore 出了毛病， 请确保你能用类似 \fBpsql\fR(1) 这样的东西从数据库中选取信息。
.SH "NOTES 注意"
.PP
 如果你的安装给template1数据库增加了任何你自己的东西， 那么请注意把 pg_dump 的输出恢复到一个真正空的数据库中； 否则你可能会收到因为重复定义所追加的对象而造成的错误信息。要制作一个没有任何本地附属物的数据库， 可以从template0而不是template1拷贝，比如：
.sp
.nf
CREATE DATABASE foo WITH TEMPLATE template0;
.sp
.fi
.PP
\fBpg_restore\fR 的局限在下面列出。
.TP 0.2i
\(bu
 当向一个已经存在的表恢复数据，并且还使用了 \fB--disable-triggers\fR 选项时， pg_restore  在插入数据前放出一些查询关闭用户表上的触发器， 在数据插入完成后重新打开它们。如果恢复的中途停止，那么系统表可能处于错误状态。
.TP 0.2i
\(bu
\fBpg_restore\fR 将不会为单一的表恢复大对象。 如果一个归档包含大对象，那么所有大对象都将被恢复。
.PP
.PP
 又见参阅 \fBpg_dump\fR(1) 的文挡获取有关 pg_dump 的局限的细节。
.PP
 一旦完成恢复，最好在每个恢复的对象上运行 \fBANALYZE\fR， 以便给优化器有用的统计。
.SH "EXAMPLES 例子"
.PP
 把一个包含大对象的叫 mydb 的数据库转储到一个tar文件：
.sp
.nf
$ \fBpg_dump -Ft -b mydb > db.tar\fR
.sp
.fi
.PP
 把这个数据库恢复到现有的叫 newdb 的数据库中（连同BLOB）：
.sp
.nf
$ \fBpg_restore -d newdb db.tar\fR
.sp
.fi
.PP
 要对项目重新排序，首先必须转储归档的目录：
.sp
.nf
$ \fBpg_restore -l archive.file > archive.list\fR
.sp
.fi
 这个文件由一行头和每个项目一行组成，比如。
.sp
.nf
;
; Archive created at Fri Jul 28 22:28:36 2000
;     dbname: birds
;     TOC Entries: 74
;     Compression: 0
;     Dump Version: 1.4-0
;     Format: CUSTOM
;
;
; Selected TOC Entries:
;
2; 145344 TABLE species postgres
3; 145344 ACL species
4; 145359 TABLE nt_header postgres
5; 145359 ACL nt_header
6; 145402 TABLE species_records postgres
7; 145402 ACL species_records
8; 145416 TABLE ss_old postgres
9; 145416 ACL ss_old
10; 145433 TABLE map_resolutions postgres
11; 145433 ACL map_resolutions
12; 145443 TABLE hs_old postgres
13; 145443 ACL hs_old
.sp
.fi
 这里分号是注释分隔符，而行开头的数字代表赋给每个项目的内部归档 ID。
.PP
 文件内的行可以注释掉，删除和/或重新排列。比如，
.sp
.nf
10; 145433 TABLE map_resolutions postgres
;2; 145344 TABLE species postgres
;4; 145359 TABLE nt_header postgres
6; 145402 TABLE species_records postgres
;8; 145416 TABLE ss_old postgres
.sp
.fi
 可以用做 pg_restore 的输入并且只会恢复项目 10 和 6，（以这个顺序）：
.sp
.nf
$ \fBpg_restore -L archive.list archive.file\fR
.sp
.fi
.SH "HISTORY 历史"
.PP
\fBpg_restore\fR 工具第一次出现在 PostgreSQL 7.1。
.SH "SEE ALSO 参见"
\fBpg_dump\fR(1), \fBpg_dumpall\fR(1), \fBpsql\fR(1)

.SH "译者"
.B Postgresql 中文网站
.B 何伟平 <laser@pgsqldb.org>
