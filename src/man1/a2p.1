.TH A2P 1 "perl 5.005, patch 03" "29/Jul/1998" "Perl Programmers Reference Guide"
.UC
.if n .hy 0
.if n .na
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.de CQ          \" put $1 in typewriter font
.ft CW
'if n "\c
'if t \\&\\$1\c
'if n \\&\\$1\c
'if n \&"
\\&\\$2 \\$3 \\$4 \\$5 \\$6 \\$7
'.ft R
..
.\" @(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2
.	\" AM - accent mark definitions
.bd B 3
.	\" fudge factors for nroff and troff
.if n \{\
.	ds #H 0
.	ds #V .8m
.	ds #F .3m
.	ds #[ \f1
.	ds #] \fP
.\}
.if t \{\
.	ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.	ds #V .6m
.	ds #F 0
.	ds #[ \&
.	ds #] \&
.\}
.	\" simple accents for nroff and troff
.if n \{\
.	ds ' \&
.	ds ` \&
.	ds ^ \&
.	ds , \&
.	ds ~ ~
.	ds ? ?
.	ds ! !
.	ds /
.	ds q
.\}
.if t \{\
.	ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.	ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.	ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.	ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.	ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.	ds ? \s-2c\h'-\w'c'u*7/10'\u\h'\*(#H'\zi\d\s+2\h'\w'c'u*8/10'
.	ds ! \s-2\(or\s+2\h'-\w'\(or'u'\v'-.8m'.\v'.8m'
.	ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.	ds q o\h'-\w'o'u*8/10'\s-4\v'.4m'\z\(*i\v'-.4m'\s+4\h'\w'o'u*8/10'
.\}
.	\" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds v \\k:\h'-(\\n(.wu*9/10-\*(#H)'\v'-\*(#V'\*(#[\s-4v\s0\v'\*(#V'\h'|\\n:u'\*(#]
.ds _ \\k:\h'-(\\n(.wu*9/10-\*(#H+(\*(#F*2/3))'\v'-.4m'\z\(hy\v'.4m'\h'|\\n:u'
.ds . \\k:\h'-(\\n(.wu*8/10)'\v'\*(#V*4/10'\z.\v'-\*(#V*4/10'\h'|\\n:u'
.ds 3 \*(#[\v'.2m'\s-2\&3\s0\v'-.2m'\*(#]
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.ds oe o\h'-(\w'o'u*4/10)'e
.ds Oe O\h'-(\w'O'u*4/10)'E
.	\" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.	\" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.	ds : e
.	ds 8 ss
.	ds v \h'-1'\o'\(aa\(ga'
.	ds _ \h'-1'^
.	ds . \h'-1'.
.	ds 3 3
.	ds o a
.	ds d- d\h'-1'\(ga
.	ds D- D\h'-1'\(hy
.	ds th \o'bp'
.	ds Th \o'LP'
.	ds ae ae
.	ds Ae AE
.	ds oe oe
.	ds Oe OE
.\}
.rm #[ #] #H #V #F C
.SH NAME
a2p \- Awk 到 Perl 翻译器
.SH "总览 (SYNOPSIS)"
\fBa2p [options] filename\fR
.SH "描述 (DESCRIPTION)"
\fIA2p\fR 从命令行或标准输入取得一个awk脚本文件，
并且向标准输出产生一个相同功能的 \fIperl\fR 脚本文件。
.SH "选项 (OPTIONS)"
可选选项有:
.IP "\fB\-D<number>\fR" 5
设置调试标记。
.IP "\fB\-F<character>\fR" 5
告诉a2p，awk脚本总是带 \fB\-F\fR 选项执行。
.IP "\fB\-n<fieldlist>\fR" 5
如果输入不分解为一个数组，你需要指定输入的各字段的名称。
假如要翻译一个用于处理密码文件的awk脚本，你应当这样:

a2p -7 -nlogin.password.uid.gid.gcos.shell.home

任何定界符都可以用来分隔字段名。
.IP "\fB\-<number>\fR" 5
使得a2p总是假设输入包含那么多字段。
.IP "\fB\-o\fR" 5
告诉a2p使用旧的awk行为。当前，唯一的区别是旧的awk总是有一个
每行的循环，即使没有对每行的操作；新的awk不是这样。
.SS "Considerations"
a2p 不能翻译得像人一样好，但是通常都做得很好。
在生成的perl脚本中，你应当检查和修改一些东西。这里是
其中的一些，没有顺序。
.PP
awk 中有一个习惯，就是将一个字符串表达式放在 \fIint()\fR 函数中
来使它强制解释为数字，即使参数已经是一个数字。
这在perl 中是不必要的，但是a2p不知道参数是不是一个数字，所以它
将它直译了。你也许想删掉它。
.PP
perl 中数字比较和字符比较是不一样的。对这两种情况，awk只有一个操作符，
但是会在运行时判断是哪一种。在这一点上a2p不对awk进行彻底的模拟。
它会猜测哪一种是你想要的。大多数时候它是对的，但是不能保证。
这样的猜测都以 ""#???"" 注释来标记。你应当
仔细检查它们，至少用perl的 \fB\-w\fR 选项来运行它们一次，这样
perl会警告你在应当使用eq 的地方使用了＝＝。
.PP
perl 不会像awk一样将不存在的数组元素创建为引用。如果你想用这种办法
来在一个for...in 循环中创建空元素，在perl中将不可能实现。
.PP
如果a2p产生了一个分段的行，用来将一列变量赋值，看上去就
像这样 (Fld1, Fld2, Fld3...) ，你应当重新用上面提到的 \fB\-n\fR 选项
运行a2p。这样可以让你命名字段。
如果它又将行分解为一个数组，那么这个脚本中其他地方可能引用了字段的数量。
.PP
awk中的exit语句不会退出。如果有 \s-1END\s0 段，它会转到那里。
在 \s-1END\s0 段中执行跳过其他程序，转向退出的awk脚本段落在perl 
中没有必要。你只要删掉 \s-1END\s0 块中的条件变量，直接退出就可以了。
.PP
perl 中有两种数组，数字下标的和关联数组。perl中的关联数组叫做
散列 "hashes"。awk中的数组总是翻译为散列，但是如果你知道
索引总是数字，你就可以将 {...} 转为 [...]。对散列的遍历用到了
\fIkeys()\fR 函数，但是对数组的散列不会。你需要修改对这样的数组进行遍历
的循环。
.PP
awk 默认 \s-1OFMT\s0 的值是 %.6g，perl默认作用相同的成分
$# 的值是 %.20g。如果你想使用 \s-1OFMT\s0 的默认值，你需要
显式地定义$#。
.PP
在循环顶部总是会出现分支操作，这是awk脚本中暗含的。很多时候
你可以将对整个记录的判断移到循环下面，这样可以减少很多分支判断。
.PP
出于美学原因，你也许想将数组的起始值 $[ 从1转为perl默认的0
但是要记住将所有数组的下标 \s-1AND\s0 和 \fIsubstr()\fR 还有 \fIindex()\fR
函数都进行更改，保证正确。
.PP
a2p会聪明地在在未处理的脚本中添加注释
"# Here is a workaround because awk is dumb"
.PP
awk脚本经常使用在shell脚本中，通过管道接受和输出文本。
大部分时候这种shell脚本"wrapper"可以和perl合并，
因为perl可以建立输入输出管道，做其他awk不能做的事情。
.PP
对\s-1RSTART\s0 和 \s-1RLENGTH\s0 变量进行引用的脚本可以简单地
修改为对变量$\`, $& 和 $\' 的引用，只要他们是在模式匹配的范围之内。
.PP
产生的perl脚本可能含有子程序来处理awk的getline和print函数。由于
a2p通常将正确性放在首位而不是效率，一般可以将子程序重写得更有效率。
.PP
为了提高效率，你可以将子程序中的return去掉，只要返回值是子程序中的
最后一个语句。a2p可以处理最简单的情况，但是不能分析嵌入程序块的情况。
.PP
\s-1ARGV\s0[0] 翻译为 \f(CW$ARGV0\fR，
但是 \s-1ARGV\s0[n] 会翻译为 \f(CW$ARGV\fR[$n]。
遍历 \s-1ARGV\s0[0] 的循环将找不到它。
.SH "环境 (ENVIRONMENT)"
a2p不使用环境变量
.SH "作者 (AUTHORS)"
Larry Wall <\fIlarry@wall.org\fR>
.SH "文件 (FILE)"
.SH "另见 (SEE ALSO)"
.PP
perl   perl 编译器和解释器
 
s2p    sed 到 perl的翻译工具
.SH "诊断 (DIAGNOSTICS)"
.SH "BUGS"
可以在运行时根据操作数来选择字符还是数字操作，从而模拟awk。
但是这样非常粗野并且无效率。另外，a2p通常都能猜对。
.PP
当前，awk语法树是静态存储的，空间可能会耗尽。
.SH "[中文版维护人]"
袁乙钧 <bbbush@163.com>
.SH "[中文版最新更新]"
.BR 2003/10/25
.SH "《中国Linux论坛man手册页翻译计划》" 
http://cmpp.linuxforum.net
