. mso zh.tmac
.\" auto-generated by docbook2man-spec $Revision: 1.1 $
.TH "GRANT" "7" "2003-11-02" "SQL - Language Statements" "SQL Commands"
.SH NAME
GRANT \- 定义访问权限

.SH SYNOPSIS
.sp
.nf
GRANT { { SELECT | INSERT | UPDATE | DELETE | RULE | REFERENCES | TRIGGER }
    [,...] | ALL [ PRIVILEGES ] }
    ON [ TABLE ] \fItablename\fR [, ...]
    TO { \fIusername\fR | GROUP \fIgroupname\fR | PUBLIC } [, ...] [ WITH GRANT OPTION ]

GRANT { { CREATE | TEMPORARY | TEMP } [,...] | ALL [ PRIVILEGES ] }
    ON DATABASE \fIdbname\fR [, ...]
    TO { \fIusername\fR | GROUP \fIgroupname\fR | PUBLIC } [, ...] [ WITH GRANT OPTION ]

GRANT { EXECUTE | ALL [ PRIVILEGES ] }
    ON FUNCTION \fIfuncname\fR ([\fItype\fR, ...]) [, ...]
    TO { \fIusername\fR | GROUP \fIgroupname\fR | PUBLIC } [, ...] [ WITH GRANT OPTION ]

GRANT { USAGE | ALL [ PRIVILEGES ] }
    ON LANGUAGE \fIlangname\fR [, ...]
    TO { \fIusername\fR | GROUP \fIgroupname\fR | PUBLIC } [, ...] [ WITH GRANT OPTION ]

GRANT { { CREATE | USAGE } [,...] | ALL [ PRIVILEGES ] }
    ON SCHEMA \fIschemaname\fR [, ...]
    TO { \fIusername\fR | GROUP \fIgroupname\fR | PUBLIC } [, ...] [ WITH GRANT OPTION ]
.sp
.fi
.SH "DESCRIPTION 描述"
.PP
\fBGRANT\fR 命令将某对象（表，视图，序列，函数过程语言，或者模式） 上的特定权限给予一个用户或者多个用户或者一组用户。 这些权限将增加到那些已经赋予的权限上，如果存在这些权限的话。
.PP
 键字 PUBLIC 表示该权限要赋予所有用户, 包括那些以后可能创建的用户。PUBLIC  可以看做是一个隐含定义好的组，它总是包括所有用户。 任何特定的用户都将拥有直接赋予他/她的权限，加上他/她所处的任何组， 以及再加上赋予 PUBLIC 的权限的总和。
.PP
 如果声明了 WITH GRANT OPTION，那么权限的受予者也可以赋予别人。 缺省的时候这是不允许的。赋权选项只能给独立的用户，而不能给组或者 PUBLIC。
.PP
 对对象的所有者（通常就是创建者）而言，没有什么权限需要赋予， 因为所有者缺省就持有所有权限。（不过，所有者出于安全考虑可以选择废弃一些他自己的权限。） 删除一个对象的权力，或者是任意修改它的权力都不是可赋予的权利所能描述的； 它是创建者固有的，并且不能赋予或撤销。
.PP
 根据对象的不同，初始的缺省权限可能包括给 PUBLIC  赋予一些权限。缺省设置对于表和模式是没有公开访问权限的； TEMP 表为数据库创建权限；EXECUTE 权限用于函数； 以及 USAGE 用于语言。对象所有者当然可以撤回这些权限。 （出于最大安全性考虑，在创建该对象的同一个事务中发出 REVOKE； 那么就不会打开给别的用户使用该对象的窗口。）
.PP
 可能的权限有：
.TP
\fBSELECT\fR
 允许对声明的表，试图，或者序列 SELECT [\fBselect\fR(7)] 任意字段。还允许做
COPY [\fBcopy\fR(7)] TO 的源。 对于序列而言，这个权限还允许使用 currval 函数。
.TP
\fBINSERT\fR
 允许向声明的表 INSERT [\fBinsert\fR(7)] 一个新行。 同时还允许做 COPY [\fBcopy\fR(7)] FROM。
.TP
\fBUPDATE\fR
 允许对声明的表中任意字段做 UPDATE [\fBupdate\fR(7)] 。 SELECT ... FOR UPDATE 也要求这个权限 （除了 SELECT 权限之外）。比如， 这个权限允许使用nextval 和 setval。
.TP
\fBDELETE\fR
 允许从声明的表中 DELETE [\fBdelete\fR(7)] 行。
.TP
\fBRULE\fR
 允许在该表/视图上创建规则。（参阅 CREATE RULE [\fBcreate_rule\fR(7)] 语句。）
.TP
\fBREFERENCES\fR
 要创建一个外键约束，你必须在参考表和被参考表上都拥有这个权限。
.TP
\fBTRIGGER\fR
 允许在声明表上创建触发器。（参阅
CREATE TRIGGER [\fBcreate_trigger\fR(7)] 语句。）
.TP
\fBCREATE\fR
 对于数据库，允许在该数据库里创建新的模式。

 对于模式，允许在该模式中创建新的对象。 要重命名一个现有对象，你必需拥有该对象并且。 对包含该对象的模式拥有这个权限。
.TP
\fBTEMPORARY\fR
.TP
\fBTEMP\fR
 允许在使用该数据库的时候创建临时表。
.TP
\fBEXECUTE\fR
 允许使用指定的函数并且可以使用任何利用这些函数实现的操作符。 这是适用于函数的唯一的一种权限类型。 （该语法同样适用于聚集函数。）
.TP
\fBUSAGE\fR
 对于过程语言， 允许使用指定过程语言创建该语言的函数。 这是适用于过程语言的唯一的一种权限类型。

 对于模式，允许访问包含在指定模式中的对象（假设该对象的所有权要求同样也设置了）。 最终这些就允许了权限接受者"查询"模式中的对象。
.TP
\fBALL PRIVILEGES\fR
 一次性给予所有适用于该对象的权限。 PRIVILEGES 关键字在 PostgreSQL 里是可选的， 但是严格的 SQL 要求有这个关键字。
.PP
 其它命令要求的权限都在相应的命令的参考页上列出。
.SH "NOTES 注意"
.PP
REVOKE [\fBrevoke\fR(7)] 命令用于删除访问权限。
.PP
 我们要注意数据库超级用户可以访问所有对象， 而不会受对象的权限设置影响。这个特点类似 Unix 系统的 root  的权限。和 root 一样，除了必要的情况，总是以超级用户身分进行操作是不明智的做法。
.PP
If a superuser chooses to issue a \fBGRANT\fR or \fBREVOKE\fR
command, the command is performed as though it were issued by the
owner of the affected object. In particular, privileges granted via
such a command will appear to have been granted by the object owner.
.PP
 目前，要在 PostgreSQL 里只对某几列赋予权限， 你必须创建一个拥有那几行的视图然后给那个视图赋予权限。
.PP
 使用 \fBpsql\fR(1) 的 \fB\\z\fR 命令获取在现有对象上的与权限有关的信息。
.sp
.nf
=> \\z mytable

        Access privileges for database "lusitania"
 Schema |  Table  |           Access privileges
--------+---------+---------------------------------------
 public | mytable | {=r/postgres,miriam=arwdRxt/postgres,"group todos=arw/postgres"}
(1 row)
.sp
.fi
\fB\\z\fR 显示的条目解释如下：
.sp
.nf
              =xxxx -- 赋予 PUBLIC 的权限
         uname=xxxx -- 赋予一个用户的权限
   group gname=xxxx -- 赋予一个组的权限

                  r -- SELECT ("读")
                  w -- UPDATE ("写")
                  a -- INSERT ("追加")
                  d -- DELETE
                  R -- RULE
                  x -- REFERENCES
                  t -- TRIGGER
                  X -- EXECUTE
                  U -- USAGE
                  C -- CREATE
                  T -- TEMPORARY
            arwdRxt -- ALL PRIVILEGES (for tables)
                  * -- 给前面权限的授权选项

              /yyyy -- 授出这个权限的用户
.sp
.fi
 用户 miriam 在建完表之后再做下面的语句， 就可以得到上面例子的结果
.sp
.nf
GRANT SELECT ON mytable TO PUBLIC;
GRANT SELECT, UPDATE, INSERT ON mytable TO GROUP todos;
.sp
.fi
.PP
 如果一个给定的对象的 "Access privileges" 字段是空的， 这意味着该对象有缺省权限（也就是说，它的权限字段是 NULL）。 缺省权限总是包括所有者的所有权限，以及根据对象的不同，可能包含一些给 PUBLIC  的权限。 对象上第一个 GRANT 或者 REVOKE  将实例化这个缺省权限（比如，产生 {=,miriam=arwdRxt}） 然后根据每次特定的需求修改它。
.SH "EXAMPLES 例子"
.PP
 把表 films 的插入权限赋予所有用户：
.sp
.nf
GRANT INSERT ON films TO PUBLIC;
.sp
.fi
.PP
 赋予用户manuel对视图kinds的所有权限：
.sp
.nf
GRANT ALL PRIVILEGES ON kinds TO manuel;
.sp
.fi
.SH "COMPATIBILITY 兼容性"
.PP
 根据 SQL 标准，在 ALL PRIVILEGES 里的 PRIVILEGES  关键字是必须的。SQL 不支持在一条命令里对多个表设置权限。
.PP
SQL 标准允许在一个表里为独立的字段设置权限：
.sp
.nf
GRANT \fIprivileges\fR
    ON \fItable\fR [ ( \fIcolumn\fR [, ...] ) ] [, ...]
    TO { PUBLIC | \fIusername\fR [, ...] } [ WITH GRANT OPTION ]
.sp
.fi
.PP
SQL 标准对其它类型的对象提供了一个 USAGE 权限：字符集，校勘，转换，域。
.PP
RULE 权限，以及在数据库，模式，语言和序列上的权限是 PostgreSQL 扩展。
.SH "SEE ALSO 参见"
.PP
REVOKE [\fBrevoke\fR(7)]
.SH "译者"
.B Postgresql 中文网站
.B 何伟平 <laser@pgsqldb.org>
