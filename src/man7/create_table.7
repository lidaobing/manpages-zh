. mso zh.tmac
.\" auto-generated by docbook2man-spec $Revision: 1.1 $
.TH "CREATE TABLE" "7" "2003-11-02" "SQL - Language Statements" "SQL Commands"
.SH NAME
CREATE TABLE \- 定义一个新表

.SH SYNOPSIS
.sp
.nf
CREATE [ [ GLOBAL | LOCAL ] { TEMPORARY | TEMP } ] TABLE \fItable_name\fR (
    { \fIcolumn_name\fR \fIdata_type\fR [ DEFAULT \fIdefault_expr\fR ] [ \fIcolumn_constraint\fR [, ... ] ]
    | \fItable_constraint\fR
    | LIKE \fIparent_table\fR [ { INCLUDING | EXCLUDING } DEFAULTS ] }  [, ... ]
)
[ INHERITS ( \fIparent_table\fR [, ... ] ) ]
[ WITH OIDS | WITHOUT OIDS ]
[ ON COMMIT { PRESERVE ROWS | DELETE ROWS | DROP } ]

where \fIcolumn_constraint\fR is:

[ CONSTRAINT \fIconstraint_name\fR ]
{ NOT NULL | NULL | UNIQUE | PRIMARY KEY |
  CHECK (\fIexpression\fR) |
  REFERENCES \fIreftable\fR [ ( \fIrefcolumn\fR ) ] [ MATCH FULL | MATCH PARTIAL | MATCH SIMPLE ]
    [ ON DELETE \fIaction\fR ] [ ON UPDATE \fIaction\fR ] }
[ DEFERRABLE | NOT DEFERRABLE ] [ INITIALLY DEFERRED | INITIALLY IMMEDIATE ]

and \fItable_constraint\fR is:

[ CONSTRAINT \fIconstraint_name\fR ]
{ UNIQUE ( \fIcolumn_name\fR [, ... ] ) |
  PRIMARY KEY ( \fIcolumn_name\fR [, ... ] ) |
  CHECK ( \fIexpression\fR ) |
  FOREIGN KEY ( \fIcolumn_name\fR [, ... ] ) REFERENCES \fIreftable\fR [ ( \fIrefcolumn\fR [, ... ] ) ]
    [ MATCH FULL | MATCH PARTIAL | MATCH SIMPLE ] [ ON DELETE \fIaction\fR ] [ ON UPDATE \fIaction\fR ] }
[ DEFERRABLE | NOT DEFERRABLE ] [ INITIALLY DEFERRED | INITIALLY IMMEDIATE ]
.sp
.fi
.SH "DESCRIPTION 描述"
.PP
\fBCREATE TABLE\fR 将在当前数据库创建一个新的， 初始为空的表。该表将由发出此命令的用户所有。
.PP
 如果给出了模式名（比如，CREATE TABLE myschema.mytable ...）， 那么表是在指定模式中创建的。否则它在当前模式中创建。临时表存在于一个特殊的模式里， 因此创建临时表的时候不能给出模式名。表名字必需和同一模式中其他表，序列，索引或者视图相区别。
.PP
\fBCREATE TABLE\fR 还自动创建一个数据类型， 该数据类型代表对应该表一行的复合类型。 因此，表不能和同模式中的现有数据类型同名。
.PP
 一个表的字段数不能超过 1600。（实际上，真正的限制比这低，因为还有元组长度的约束）。
.PP
 可选的约束子句声明约束（或者测试），新行或者更新的行必须满足这些约束才能成功插入或更新。 约束是一个它是一个 SQL 对象，它以多种方式协助我们协助我们在表上定义有效的数值集合。
.PP
 定义约束又两种方法：表约束和列约束。一个列约束是作为一个列定义的一部分定义的。 而表约束并不和某个列绑在一起， 它可以作用于多于一个列上。每个列约束也可以写成表约束； 如果某个约束只影响一个列，那么列约束只是符号上的简洁方式而已。
.SH "PARAMETERS 参数"
.TP
\fBTEMPORARY 或 TEMP\fR
 如果声明了此参数，则该表创建为临时表。临时表在会话结束时自动删除， 或者是（可选）在当前事务的结尾（参阅下面的 ON COMMIT）。 现有同名永久表在临时表存在期间在本会话过程中是不可见的， 除非它们是用模式修饰的名字引用的。 任何在临时表上创建的索引也都会自动删除。

 我们可以选择在 TEMPORARY 或 TEMP 前面放上 GLOBAL 或者 LOCAL。 这样对 PostgreSQL 没有任何区别，可以参阅 Compatibility [\fBcreate_table\fR(7)]。
.TP
\fB\fItable_name\fB\fR
 要创建的表的名字（可以用模式修饰）。
.TP
\fB\fIcolumn_name\fB\fR
 在新表中要创建的字段名字。
.TP
\fB\fIdata_type\fB\fR
 该字段的数据类型。它可以包括数组说明符。
.TP
\fBDEFAULT\fR
DEFAULT 子句给它所出现的字段一个缺省数值。 该数值可以是任何不含变量的表达式（不允许使用子查询和对本表中的其它字段的交叉引用）。 缺省表达式的数据类型必须和字段类型匹配。

 缺省表达式将被用于任何未声明该字段数值的插入操作。 如果字段上没有缺省值，那么缺省是 NULL。
.TP
LIKE 子句声明一个表，新表自动从这个表里面继承所有字段名， 他们的数据类型，以及非空约束。

 和 INHERITS 不同，新表与继承过来的表之间在创建动作完毕之后是完全无关的。 插入新表的数据不会在父表中表现出来。
 
 字段缺省表达式只有在声明了 INCLUDING DEFAULTS 之后才会继承过来。 缺省是排除缺省表达式。
.TP
\fBINHERITS ( \fIparent_table\fB [, ... ] )\fR
 可选的 INHERITS 子句声明一列表，这个新表自动从这列表中继承所有字段。 如果在多于一个父表中存在同名的字段，那么就会报告一个错误，除非这些字段的数据类型在每个父表里都是匹配的。 如果没有冲突，那么重复的字段在新表中融合成一个字段。 如果新表的字段名列表中包括和继承的字段同名的，那么它的数据类型也必须和上面一样与继承字段匹配，并且这些字段定义会融合成一个。 不过，同名的继承和新字段声明可以声明不同的约束：所有的继承过来的约束以及声明的约束都融合到一起，并且全部应用于新表。 如果新表为该字段明确的声明了一个缺省数值，那么此缺省数值覆盖任何来自继承字段声明的缺省值。 否则，任何为该字段声明了缺省数值的父表都必须声明相同的缺省，否则就会报告一个错误。
.TP
\fBWITH OIDS\fR
.TP
\fBWITHOUT OIDS\fR
 这个可选的子句声明新表中的行是否应该拥有赋予它们的 OID （对象标识）。 缺省是有 OID。（如果新表从任何有 OID 的表继承而来，那么就算这条命令说了 WITHOUT OIDS， 也会强制 WITH OIDS。）

 声明 WITHOUT OIDS 允许用户禁止为行或者表生成 OID。 这么做对大表是值得的，因为这样可以减少 OID 消耗并且推迟 32 位 OID 计数器的消耗。 一旦该计数器重叠，那么就不能再假设 OID 的唯一，这样它的实用性就大打折扣。 声明 WITHOUT OIDS 还会减少在磁盘上存储每行的空间，每行减少 4 字节，因此也可以改进性能。
.TP
\fBCONSTRAINT \fIconstraint_name\fB\fR
 列或表约束的可选名字。如果没有声明，则由系统生成一个名字。
.TP
\fBNOT NULL\fR
 字段不允许包含 NULL 数值。
.TP
\fBNULL\fR
 该字段允许包含 NULL 数值。这是缺省。

 这个子句的存在只是为和那些非标准 SQL 数据库兼容。 我们不建议在新应用中使用它。
.TP
\fBUNIQUE (column constraint)\fR
.TP
\fBUNIQUE ( \fIcolumn_name\fB [, ... ] ) (table constraint)\fR
UNIQUE 声明一个规则，表示一个表里的一个或者多个独立的字段组合的分组只能包含唯一的数值。 表的唯一约束的行为和列约束的一样，只不过多了跨多行的能力。

 对于唯一约束的用途而言，系统认为 NULL 数值是不相等的。

 每个唯一表约束都必须命名一个字段的集合，该集合必须和其它唯一约束命名字段集合或者该表定义的主键约束不同。 （否则就只是同样的约束写了两次。）
.TP
\fBPRIMARY KEY (column constraint)\fR
.TP
\fBPRIMARY KEY ( \fIcolumn_name\fB [, ... ] ) (table constraint)\fR
 主键约束表明表中的一个或者一些字段只能包含唯一（不重复）非 NULL 的数值。 从技术上讲，PRIMARY KEY 只是 UNIQUE 和 NOT NULL 的组合，不过把一套字段标识为主键同时也体现了模式设计的元数据， 因为主键意味着其它表可以拿这套字段用做行的唯一标识。

 一个表只能声明一个主键，不管是作为字段约束还是表约束。

 主键约束应该定义在同个表上的一个与其它唯一约束所定义的不同的字段集合上。
.TP
\fBCHECK (\fIexpression\fB)\fR
CHECK 约束声明一个生成布尔结果的子句， 一次插入或者更新操作若想成功则里面的新行或者被更新的行必须满足这个条件。 声明为字段约束的检查约束应该只引用该字段的数值，而在表约束里出现的表达式可以引用多个字段。

 目前，CHECK 表达式不能包含子查询也不能引用除当前行字段之外的变量。
.TP
\fBREFERENCES \fIreftable\fB [ ( \fIrefcolumn\fB ) ] [ MATCH \fImatchtype\fB ] [ ON DELETE \fIaction\fB ] [ ON UPDATE \fIaction\fB ] (column constraint)\fR
.TP
\fBFOREIGN KEY ( \fIcolumn\fB [, ... ] )\fR
 这些子句声明一个外键约束，外键约束声明一个由新表中一列或者多列组成的组应该只包含匹配引用的表 reftable 中对应引用的字段 refcolumn 中的数值。 如果省略 refcolumn， 则使用 reftable 的主键。 被引用字段必须是被引用表中的唯一字段或者主键。

 向这些字段插入的数值将使用给出的匹配类型与参考表中的参考列中的数值进行匹配。 有三种匹配类型：MATCH FULL， MATCH PARTIAL，和 MATCH SIMPLE，它也是缺省匹配类型。 MATCH FULL 将不允许一个多字段外键的字段为 NULL，除非所有外键字段都为 NULL。 MATCH SIMPLE 允许某些外键字段为 NULL 而外键的其它部分不是 NULL。MATCH PARTIAL  还没实现。

 另外，当被参考字段中的数据改变的时候，那么将对本表的字段中的数据执行某种操作。 ON DELETE 子句声明当被参考表中的被参考行将被删除的时候要执行的操作。 类似，ON UPDATE 子句声明被参考表中被参考字段更新为新值的时候要执行的动作。 如果该行被更新，但被参考的字段实际上没有变化，那么就不会有任何动作。 下面是每个子句的可能的动作：
.RS
.TP
\fBNO ACTION\fR
 生成一个错误，表明删除或者更新将产生一个违反外键约束的动作。 它是缺省动作。
.TP
\fBRESTRICT\fR
 和 NO ACTION 一样，只是动作不可推迟， 即使约束剩下的部分是可以推迟的也马上发生。
.TP
\fBCASCADE\fR
 删除任何引用了被删除行的行，或者分别把引用行的字段值更新为被参考字段的新数值。
.TP
\fBSET NULL\fR
 把引用行数值设置为 NULL。
.TP
\fBSET DEFAULT\fR
 把引用列的数值设置为它们的缺省值。
.RE
.PP

 如果主键字段经常更新，那么我们给 REFERENCES  字段增加一个索引可能是合适的，这样与 REFERENCES 字段相关联的 NO ACTION  和 CASCADE 动作可以更有效地执行。
.TP
\fBDEFERRABLE\fR
.TP
\fBNOT DEFERRABLE\fR
 这两个关键字设置该约束是否可推迟。一个不可推迟的约束将在每条命令之后马上检查。 可以推迟的约束检查可以推迟到事务结尾（使用 SET CONSTRAINTS [\fBset_constraints\fR(7)]  命令）。 缺省是 NOT DEFERRABLE。目前只有外键约束接受这个子句。所有其它约束类型都是不可推迟的。
.TP
\fBINITIALLY IMMEDIATE\fR
.TP
\fBINITIALLY DEFERRED\fR
 如果约束是可推迟的，那么这个子句声明检查约束的缺省时间。 如果约束是 INITIALLY IMMEDIATE， 那么每条语句之后就检查它。这个是缺省。如果约束是 INITIALLY DEFERRED，那么只有在事务结尾才检查它。 约束检查的时间可以用 SET CONSTRAINTS [\fBset_constraints\fR(7)] 命令修改。
.TP
\fBON COMMIT\fR
 我们可以用 ON COMMIT 控制临时表在事务块结尾的行为。这三个选项是：
.RS
.TP
\fBPRESERVE ROWS\fR
 在事务结尾不发生任何特定的动作。这是缺省行为。
.TP
\fBDELETE ROWS\fR
 临时表的所有行在每次事务结尾都被删除。实际上，在每次提交的时候都自动 \fBtruncate\fR(7)  。
.TP
\fBDROP\fR
 在当前事务块的结尾，临时表将被删除。
.RE
.PP
.SH "NOTES 注意"
.TP 0.2i
\(bu
 如果一个应用使用了 OID 标识表中的特定行，那么我们建议在该表的 oid 字段上创建一个唯一约束，以确保该表的 OID 即使在计数器重叠之后也是唯一的。如果你需要一个整个数据库范围的唯一标识， 那么就要避免假设 OID 是跨表唯一的，你可以用 tableoid 和行 OID 的组合来实现这个目的。 （将来的 PostgreSQL 很可能为每个表使用独立的 OID 计数器， 因此包括 tableoid 组成数据库范围内的唯一标识将是必须的，而不是可选的。）
.sp
.RS
.B "提示:" 
对那些没有主键的表，我们不建议使用 WITHOUT OIDS， 因为如果既没有 OID 又没有唯一数据键字，那么就很难标识特定的行。
.RE
.sp
.TP 0.2i
\(bu
PostgreSQL 自动为每个唯一约束和主键约束创建一个索引以确保唯一性。 因此，我们不必为主键字段创建明确的索引。（参阅 CREATE INDEX [\fBcreate_index\fR(7)]获取更多信息。）
.TP 0.2i
\(bu
 唯一约束和主键在目前的实现里是不能继承的。 这样，如果把继承和唯一约束组合在一起会导致无法运转。
.SH "EXAMPLES 例子"
.PP
 创建表 films 和 distributors：
.sp
.nf
CREATE TABLE films (
    code        char(5) CONSTRAINT firstkey PRIMARY KEY,
    title       varchar(40) NOT NULL,
    did         integer NOT NULL,
    date_prod   date,
    kind        varchar(10),
    len         interval hour to minute
);
.sp
.fi
.sp
.nf
CREATE TABLE distributors (
     did    integer PRIMARY KEY DEFAULT nextval('serial'),
     name   varchar(40) NOT NULL CHECK (name <> '')
);
.sp
.fi
.PP
 创建一个带有 2 维数组的表：
.sp
.nf
CREATE TABLE array (
    vector  int[][]
);
.sp
.fi
.PP
 为表 films 定义一个唯一表约束。 唯一表约束可以在表的一个或多个字段上定义：
.sp
.nf
CREATE TABLE films (
    code        char(5),
    title       varchar(40),
    did         integer,
    date_prod   date,
    kind        varchar(10),
    len         interval hour to minute,
    CONSTRAINT production UNIQUE(date_prod)
);
.sp
.fi
.PP
 定义一个检查列约束：
.sp
.nf
CREATE TABLE distributors (
    did     integer CHECK (did > 100),
    name    varchar(40)
);
.sp
.fi
.PP
 定义一个检查表约束：
.sp
.nf
CREATE TABLE distributors (
    did     integer,
    name    varchar(40)
    CONSTRAINT con1 CHECK (did > 100 AND name <> '')
);
.sp
.fi
.PP
 为表 films 定义一个主键表约束。 主键表约束可以定义在表上的一个或多个字段。
.sp
.nf
CREATE TABLE films (
    code        char(5),
    title       varchar(40),
    did         integer,
    date_prod   date,
    kind        varchar(10),
    len         interval hour to minute,
    CONSTRAINT code_title PRIMARY KEY(code,title)
);
.sp
.fi
.PP
 为表 distributors 定义一个主键约束。 下面两个例子是等效的，第一个例子使用了表约束语法， 第二个使用了列约束表示法。
.sp
.nf
CREATE TABLE distributors (
    did     integer,
    name    varchar(40),
    PRIMARY KEY(did)
); 
.sp
.fi
.sp
.nf
CREATE TABLE distributors (
    did     integer PRIMARY KEY,
    name    varchar(40)
);
.sp
.fi
.PP
 下面这个例子给字段 name 赋予了一个文本常量缺省值， 并且将字段 did 的缺省值安排为通过选择序列对象的下一个值生成。 modtime 的缺省值将是该行插入的时候的时间。
.sp
.nf
CREATE TABLE distributors (
    name      varchar(40) DEFAULT 'Luso Films',
    did       integer DEFAULT nextval('distributors_serial'),
    modtime   timestamp DEFAULT current_timestamp
);
.sp
.fi
.PP
 在表 distributors 上定义两个 NOT NULL 列约束，其中之一明确给出了名字：
.sp
.nf
CREATE TABLE distributors (
    did     integer CONSTRAINT no_null NOT NULL,
    name    varchar(40) NOT NULL
);
.sp
.fi
.PP
 为 name 字段定义一个唯一约束：
.sp
.nf
CREATE TABLE distributors (
    did     integer,
    name    varchar(40) UNIQUE
);
.sp
.fi
 上面的和下面这样作为一个表约束声明是一样的：
.sp
.nf
CREATE TABLE distributors (
    did     integer,
    name    varchar(40),
    UNIQUE(name)
);
.sp
.fi
.SH "COMPATIBILITY 兼容性"
.PP
\fBCREATE TABLE\fR 遵循 SQL92 和 SQL99 的一个子集，一些例外情况在下面列出。
.SS "TEMPORARY TABLES 临时表"
.PP
 尽管 CREATE TEMPORARY TABLE 的语法和 SQL 标准的类似， 但是效果是不同的。在标准里，临时表只是定义一次并且自动存在（从空内容开始）于任何需要它们的会话中。 PostgreSQL 要求每个会话为它们使用的每个临时表发出它们自己的 CREATE TEMPORARY TABLE 命令。 这样就允许不同的会话将相同的临时表名字用于不同的目的，而标准的实现方法则把一个临时表名字约束为具有相同的表结构。
.PP
 标准定义的临时表的行为被广泛地忽略了。PostgreSQL  在这方面上地行为类似于许多其它 SQL 数据库
.PP
 标准中在全局和局部地临时表之间的区别在 PostgreSQL  里不存在，因为这种区别取决于模块的概念，而 PostgreSQL  没有这个概念。出于兼容考虑，PostgreSQL 将接受临时表声明中的 GLOBAL 和 LOCAL 关键字， 但是他们没有作用。
.PP
 临时表的 ON COMMIT 子句也类似于 SQL 标准， 但是有些区别。如果忽略了 ON COMMIT 子句，SQL 声明缺省的行为是 ON COMMIT DELETE ROWS。 但是 PostgreSQL 里的缺省行为是 ON COMMIT PRESERVE ROWS。 在 SQL 里不存在 ON COMMIT DROP。
.SS "COLUMN CHECK CONSTRAINTS 字段检查约束"
.PP
 SQL 标准说 CHECK 字段约束只能引用他们施用的字段； 只有 CHECK 表约束才能引用多个字段。PostgreSQL 并不强制这个限制；它把字段和表约束看作相同的东西。
.SS "NULL ``CONSTRAINT'' NULL约束"
.PP
NULL "约束"（实际上不是约束）是 PostgreSQL 对 SQL 标准的扩展， 包括它是为了和其它一些数据库系统兼容（以及为了和 NOT NULL 约束对称）。因为它是任何字段的缺省，所以它的出现只是噪音而已。
.SS "INHERITANCE 继承"
.PP
 通过 INHERITS 子句的多重继承是 PostgreSQL 语言的扩展。 SQL99（但不包括 SQL92）使用不同的语法和语义定义了单继承。 SQL99 风格的继承还没有在 PostgreSQL 中实现。
.SS "OBJECT IDS 对象ID"
.PP
PostgreSQL 的 OID 的概念不标准。
.SS "ZERO-COLUMN TABLES 零行表"
.PP
PostgreSQL 允许创建没有字段的表 （比如，CREATE TABLE foo();）。这是对 SQL 标准的扩展， 标准不允许存在零字段表。零字段表本身没什么用，但是禁止他们会给 ALTER TABLE DROP COLUMN带来很奇怪的情况，所以，这个时候忽视标准的限制好想很清楚。
.SH "SEE ALSO 参见"
ALTER TABLE [\fBalter_table\fR(7)], DROP TABLE [\fBdrop_table\fR(l)]
.SH "译者"
.B Postgresql 中文网站
.B 何伟平 <laser@pgsqldb.org>

