. mso zh.tmac
.\" auto-generated by docbook2man-spec $Revision: 1.1 $
.TH "CREATE SEQUENCE" "7" "2003-11-02" "SQL - Language Statements" "SQL Commands"
.SH NAME
CREATE SEQUENCE \- 创建一个新的序列发生器

.SH SYNOPSIS
.sp
.nf
CREATE [ TEMPORARY | TEMP ] SEQUENCE \fIname\fR [ INCREMENT [ BY ] \fIincrement\fR ]
    [ MINVALUE \fIminvalue\fR | NO MINVALUE ] [ MAXVALUE \fImaxvalue\fR | NO MAXVALUE ]
    [ START [ WITH ] \fIstart\fR ] [ CACHE \fIcache\fR ] [ [ NO ] CYCLE ]
.sp
.fi
.SH "DESCRIPTION 描述"
.PP
\fBCREATE SEQUENCE\fR 将向当前数据库里增加一个新的序列号生成器。 包括创建和初始化一个新的名为 name的单行表。生成器将为使用此命令的用户所有。
.PP
 如果给出了一个模式名，那么该序列是在指定模式中创建的。 否则它会在当前模式中创建临时序列存在于一个特殊的模式中，因此如果创建一个临时序列的时候， 不能给出模式名。 序列名必需和同一模式中的其他序列，表，索引，或者视图不同。
.PP
 在序列创建后，你可以使用函数
\fBnextval\fR,
\fBcurrval\fR, 和
\fBsetval\fR
操作序列。这些函数在 ``Sequence-Manipulation Functions'' 中有详细文档。
.PP
 尽管你不能直接更新一个序列，但你可以使用象
.sp
.nf
SELECT * FROM \fIname\fR;
.sp
.fi
 检查一个序列的参数和当前状态。特别是序列的 last_value 字段显示了任意后端进程分配的最后的数值。 （当然，这些值在被打印出来的时候可能已经过时了 --- 如果其它进程正积极地使用 nextval。）
.SH "PARAMETERS 参数"
.TP
\fBTEMPORARY or TEMP\fR
 如果声明了这个修饰词，那么该序列对象只为这个会话创建， 并且在会话结束的时候自动删除。在临时序列存在的时候， 同名永久序列是不可见的（在同一会话里），除非它们是用模式修饰的名字引用的。
.TP
\fB\fIname\fB\fR
 将要创建的序列号名（可以用模式修饰）。
.TP
\fB\fIincrement\fB\fR
INCREMENT BY \fIincrement\fR  子句是可选的。一个正数将生成一个递增的序列， 一个负数将生成一个递减的序列。缺省值是一（1）。
.TP
\fB\fIminvalue\fB\fR
.TP
\fBNO MINVALUE\fR
 可选的子句 MINVALUE minvalue  决定一个序列可生成的最小值。 如果没有声明这个子句或者声明了 NO MINVALUE，那么就使用缺省。 缺省分别是递增序列为 1 递减为 -263-1。
.TP
\fB\fImaxvalue\fB\fR
.TP
\fBNO MAXVALUE\fR
 使用可选子句 MAXVALUE maxvalue  决定序列的最大值。 如果没有声明这个子句或者声明了 NO MAXVALUE，那么就使用缺省。 缺省的分别是递增为 263-1，递减为 -1。
.TP
\fB\fIstart\fB\fR
 可选的 START WITH start  子句  使序列可以从任意位置开始。缺省初始值是递增序列为 minvalue  递减序列为 maxvalue.
.TP
\fB\fIcache\fB\fR
CACHE cache  选项使序列号预分配并且为快速访问存储在内存里面。 最小值（也是缺省值）是1（一次只能生成一个值, 也就是说没有缓存）这也是缺省。
.TP
\fBCYCLE\fR
.TP
\fBNO CYCLE\fR
 可选的CYCLE关键字可用于使序列到达 最大值（maxvalue） 或 最小值（minvalue）  时可复位并继续下去。如果达到极限，生成的下一个数据将分别是 最小值（minvalue） 或 最大值（maxvalue）。

 如果声明了可选的关键字 NO CYCLE， 那么在序列达到其最大值之后任何对 nextval 的调用都强返回一个错误。 如果既没有声明 CYCLE 也没有声明 NO CYCLE， 那么 NO CYCLE 是缺省。
.SH "NOTES 注意"
.PP
 使用 DROP SEQUENCE 语句来删除序列。
.PP
 序列是基于 \fBbigint\fR 运算的，因此其范围不能超过八字节的整数范围（-9223372036854775808 到 9223372036854775807）。 在一些老一点的平台上可能没有对八字节整数的编译器支持， 这种情况下序列使用普通的 integer 运算（范围是 -2147483648 到 +2147483647）。
.PP
 如果 cache 设置大于一， 并且这个序列对象将被用于并发多会话的场合，那么可能会有不可预料的结果发生。 每个会话在一次访问序列对象的过程中将分配并缓存随后的序列值，并且相应增加序列对象的 last_value。 这样，同一个事务中的随后的 cache-1 次 nextval  将只是返回预先分配的数值，而不用动序列对象。因此，任何在一个会话中分配但是没有使用的数字都将在会话结尾丢失，导致序列里面出现"空洞"。
.PP
 另外，尽管系统保证为多个会话分配独立的序列值，但是如果考虑所有会话， 那么这个数值可能会丢失顺序。比如，如果 cache  设置为 10，那么会话 A 保留了 1..10 并且返回 nextval=1， 然后会话 B 可能会保留 11..20 然后在会话 A 生成 nextval=2 之前返回 nextval=11。因此，对于 cache 设置为一的情况，我们可以安全地假设 nextval 值是顺序生成的； 而如果把 cache 设置得大于一， 那么你只能假设 nextval 值总是唯一得，而不是完全顺序地生成。 同样，last_value 将反映任何会话保留的最后的数值，不管它是否曾被 nextval 返回。
.PP
 另外一个考虑是在这样的序列上执行的 setval 将不会被其它会话注意到，直到它们用光他们缓存的数值。
.SH "EXAMPLES 例子"
.PP
 创建一个叫 serial 的递增序列，从101开始：
.sp
.nf
CREATE SEQUENCE serial START 101;
.sp
.fi
.PP
 从此序列中选出下一个数字：
.sp
.nf
SELECT nextval('serial');
    
 nextval
---------
     114
.sp
.fi
.PP
 在一个 INSERT 中使用此序列：
.sp
.nf
INSERT INTO distributors VALUES (nextval('serial'), 'nothing');
.sp
.fi
.PP
 在一个 COPY FROM 后更新序列：
.sp
.nf
BEGIN;
COPY distributors FROM 'input_file';
SELECT setval('serial', max(id)) FROM distributors;
END;
.sp
.fi
.SH "COMPATIBILITY 兼容性"
.PP
\fBCREATE SEQUENCE\fR 是 PostgreSQL  语言扩展。 在 SQL 标准里没有 CREATE SEQUENCE 语句。
.SH "译者"
.B Postgresql 中文网站
.B 何伟平 <laser@pgsqldb.org>
