. mso zh.tmac
.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.14
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLFAQ9 1"
.TH PERLFAQ9 7 "2003-11-25" "perl v5.8.3" "Perl Programmers Reference Guide"
.SH "NAME"
perlfaq9 \- 网络 (2003/01/31 17:36:57 )
.SH "DESCRIPTION 描述"
.IX Header "DESCRIPTION"
网络通信，互联网以及少量有关 web 的内容
.Sh "What is the correct form of response from a \s-1CGI\s0 script?"
.IX Subsection "一个 CGI 脚本的回应的正确格式是什么？"
(Alan Flavell <flavell+www@a5.ph.gla.ac.uk> answers...)
.PP
The Common Gateway Interface (\s-1CGI\s0) specifies a software interface between
a program (\*(L"\s-1CGI\s0 script\*(R") and a web server (\s-1HTTPD\s0). It is not specific
to Perl, and has its own FAQs and tutorials, and usenet group,
comp.infosystems.www.authoring.cgi
.PP
The original \s-1CGI\s0 specification is at: http://hoohoo.ncsa.uiuc.edu/cgi/
.PP
Current best-practice \s-1RFC\s0 draft at: http://CGI\-Spec.Golux.Com/
.PP
Other relevant documentation listed in: http://www.perl.org/CGI_MetaFAQ.html
.PP
These Perl FAQs very selectively cover some \s-1CGI\s0 issues. However, Perl
programmers are strongly advised to use the \s-1CGI\s0.pm module, to take care
of the details for them.
.PP
The similarity between \s-1CGI\s0 response headers (defined in the \s-1CGI\s0
specification) and \s-1HTTP\s0 response headers (defined in the \s-1HTTP\s0
specification, \s-1RFC2616\s0) is intentional, but can sometimes be confusing.
.PP
The \s-1CGI\s0 specification defines two kinds of script: the \*(L"Parsed Header\*(R"
script, and the \*(L"Non Parsed Header\*(R" (\s-1NPH\s0) script. Check your server
documentation to see what it supports. \*(L"Parsed Header\*(R" scripts are
simpler in various respects. The \s-1CGI\s0 specification allows any of the
usual newline representations in the \s-1CGI\s0 response (it's the server's
job to create an accurate \s-1HTTP\s0 response based on it). So \*(L"\en\*(R" written in
text mode is technically correct, and recommended. \s-1NPH\s0 scripts are more
tricky: they must put out a complete and accurate set of \s-1HTTP\s0
transaction response headers; the \s-1HTTP\s0 specification calls for records
to be terminated with carriage-return and line\-feed, i.e \s-1ASCII\s0 \e015\e012
written in binary mode.
.PP
Using \s-1CGI\s0.pm gives excellent platform independence, including \s-1EBCDIC\s0
systems. \s-1CGI\s0.pm selects an appropriate newline representation
($CGI::CRLF) and sets binmode as appropriate.
.Sh "我的 CGI 脚本从命令行执行正常，但是在浏览器中不行 (500 Server Error)。"
.IX Subsection "My CGI script runs from the command line but not the browser.  (500 Server Error)"
可能有很多事错了。可以仔细阅读 \*(L"Troubleshooting
Perl \s-1CGI\s0 scripts\*(R" guide, 位置是
.PP
.Vb 1
\&        http://www.perl.org/troubleshooting_CGI.html
.Ve
.PP
如果接下来，你能证明你已阅读了 FAQ 并且你的问题不是那么简单，非叁言两语即可回答的话，那麽您 post到 comp.infosystems.www.authoring.cgi上（如果是有关 HTTP 、 HTML ，或 CGI通信协定）的问题可能也会得到口气和缓而有用的答覆。表面上看似 Perl，但骨子里是 CGI之类的问题，如果 post到 comp.lang.perl.misc人家可能就不会这麽乐意地接受了。
.PP
几个实用的 FAQ，相关文档和查错向导列在 \s-1CGI\s0 Meta \s-1FAQ\s0 中：
.PP
.Vb 1
\&        http://www.perl.org/CGI_MetaFAQ.html
.Ve
.Sh "如何从 CGI 程序中得到好一点的错误提示？"
.IX Subsection "How can I get better error messages from a CGI program?"
Use the CGI::Carp module.  It replaces \f(CW\*(C`warn\*(C'\fR and \f(CW\*(C`die\*(C'\fR, plus the
normal Carp modules \f(CW\*(C`carp\*(C'\fR, \f(CW\*(C`croak\*(C'\fR, and \f(CW\*(C`confess\*(C'\fR functions with
more verbose and safer versions.  It still sends them to the normal
server error log.
.PP
.Vb 3
\&    use CGI::Carp;
\&    warn "This is a complaint";
\&    die "But this one is serious";
.Ve
.PP
The following use of CGI::Carp also redirects errors to a file of your choice,
placed in a \s-1BEGIN\s0 block to catch compile-time warnings as well:
.PP
.Vb 6
\&    BEGIN {
\&        use CGI::Carp qw(carpout);
\&        open(LOG, ">>/var/local/cgi-logs/mycgi-log")
\&            or die "Unable to append to mycgi-log: $!\en";
\&        carpout(*LOG);
\&    }
.Ve
.PP
You can even arrange for fatal errors to go back to the client browser,
which is nice for your own debugging, but might confuse the end user.
.PP
.Vb 2
\&    use CGI::Carp qw(fatalsToBrowser);
\&    die "Bad error here";
.Ve
.PP
Even if the error happens before you get the \s-1HTTP\s0 header out, the module
will try to take care of this to avoid the dreaded server 500 errors.
Normal warnings still go out to the server error log (or wherever
you've sent them with \f(CW\*(C`carpout\*(C'\fR) with the application name and date
stamp prepended.
.Sh "如何将字符串中的 HTML 删除？"
.IX Subsection "How do I remove HTML from a string?"
最正确（尽管不是最快）的方法是使用 HTML::Parse模组（可由 CPAN取得，是所有写 Web程式者必备的 libwww-perl 套件的一部分）。另一中最正确的办法是使用 HTML::FormatText，它不仅删除了 \s-1HTML\s0，同时也试图对结果文本进行简单的格式化。
.PP
许多人尝试用简陋的正规表示式来解决这个问题，譬如说像 \f(CW\*(C`s/<.*?>//g\*(C'\fR，但这个式子在很多情况下会失败，因为要处理的字串可能会跨越断行字元，也可能含有被 quote【跳脱】的箭头号，或有 HTML comment出现；再加上一些疏忽，譬如，人们常忘了转换如 < 的 entities（跳脱字 元\f(CW\*(C`&lt;\*(C'\fR）。
.PP
以下这个「简陋」的方法对大多数的档案都有效：
.PP
.Vb 2
\&    #!/usr/bin/perl -p0777
\&    s/<(?:[^>'"]*|(['"]).*?\e1)*>//gs
.Ve
.PP
如果您想要更完整的解法，请看叁部曲的 striphtml 程式，
http://www.cpan.org/authors/Tom_Christiansen/scripts/striphtml.gz
\&.
.PP
Here are some tricky cases that you should think about when picking
a solution:
.PP
.Vb 1
\&    <IMG SRC = "foo.gif" ALT = "A > B">
.Ve
.PP
.Vb 2
\&    <IMG SRC = "foo.gif"
\&         ALT = "A > B">
.Ve
.PP
.Vb 1
\&    <!-- <A comment> -->
.Ve
.PP
.Vb 1
\&    <script>if (a<b && a>c)</script>
.Ve
.PP
.Vb 1
\&    <# Just data #>
.Ve
.PP
.Vb 1
\&    <![INCLUDE CDATA [ >>>>>>>>>>>> ]]>
.Ve
.PP
If \s-1HTML\s0 comments include other tags, those solutions would also break
on text like this:
.PP
.Vb 3
\&    <!-- This section commented out.
\&        <B>You can't see me!</B>
\&    -->
.Ve
.Sh "如何萃取 URL?"
.IX Subsection "How do I extract URLs?"
可以简单地从 HTML 中得到所有种类的 URL，只要使用 \f(CW\*(C`HTML::SimpleLinkExtor\*(C'\fR 模块，它可以处理锚，图像，对象，桢，其他包含 URL 的标签。如果需要更复杂的东西，可以创建 \f(CW\*(C`HTML::LinkExtor\*(C'\fR 的子类或使用 \f(CW\*(C`HTML::Parser\*(C'\fR. 你甚至可以用
\&\f(CW\*(C`HTML::SimpleLinkExtor\*(C'\fR 作为范例，来书写适合你特殊需要的程序。
.PP
You can use URI::Find to extract URLs from an arbitrary text document.
.PP
Less complete solutions involving regular expressions can save
you a lot of processing time if you know that the input is simple.  One
solution from Tom Christiansen runs 100 times faster than most
module based approaches but only extracts URLs from anchors where the first
attribute is \s-1HREF\s0 and there are no other attributes.
.PP
.Vb 7
\&        #!/usr/bin/perl -n00
\&        # qxurl - tchrist@perl.com
\&        print "$2\en" while m{
\&            < \es*
\&              A \es+ HREF \es* = \es* (["']) (.*?) \e1
\&            \es* >
\&        }gsix;
.Ve
.Sh "如何从用户的机器上下载文件？如何打开其他机器上的文件？"
.IX Subsection "How do I download a file from the user's machine?  How do I open a file on another machine?"
In this case, download means to use the file upload feature of \s-1HTML\s0
forms.  You allow the web surfer to specify a file to send to your web
server.  To you it looks like a download, and to the user it looks
like an upload.  No matter what you call it, you do it with what's
known as \fBmultipart/form\-data\fR encoding.  The \s-1CGI\s0.pm module (which
comes with Perl as part of the Standard Library) supports this in the
\&\fIstart_multipart_form()\fR method, which isn't the same as the \fIstartform()\fR
method.
.PP
See the section in the \s-1CGI\s0.pm documentation on file uploads for code
examples and details.
.Sh "如何在 HTML 添加一个弹出菜单?"
.IX Subsection "How do I make a pop-up menu in HTML?"
用 <SELECT> 和 <OPTION>这两个标签。 CGI.pm模组（可由 CPAN取得）对这个 widget【此指跳出式选单这个介面成分】还有许多其他的介面成分都有支援【即有制作动态标签的函式】，其中有些是以巧妙模拟的方 式达成。
.Sh "如何获取 HTML 文件?"
.IX Subsection "How do I fetch an HTML file?"
有一个方法是，如果您的系统上装有 lynx一类的文字模式的 HTML浏览器的话，那麽可以这麽做：
.PP
.Vb 2
\&    $html_code = `lynx -source $url`;
\&    $text_data = `lynx -dump $url`;
.Ve
.PP
收录在 CPAN里的 libwww-perl (LWP)模组则提供了更强的方法来做这件事。它不但可钻过 proxies，而且也不需要 lynx：
.PP
.Vb 3
\&    # simplest version
\&    use LWP::Simple;
\&    $content = get($URL);
.Ve
.PP
.Vb 3
\&    # or print HTML from a URL
\&    use LWP::Simple;
\&    getprint "http://www.linpro.no/lwp/";
.Ve
.PP
.Vb 11
\&    # or print ASCII from HTML from a URL
\&    # also need HTML-Tree package from CPAN
\&    use LWP::Simple;
\&    use HTML::Parser;
\&    use HTML::FormatText;
\&    my ($html, $ascii);
\&    $html = get("http://www.perl.com/");
\&    defined $html
\&        or die "Can't fetch HTML from http://www.perl.com/";
\&    $ascii = HTML::FormatText->new->format(parse_html($html));
\&    print $ascii;
.Ve
.Sh "如何根据提交的内容自动生成一个 HTML ?"
.IX Subsection "How do I automate an HTML form submission?"
If you're submitting values using the \s-1GET\s0 method, create a \s-1URL\s0 and encode
the form using the \f(CW\*(C`query_form\*(C'\fR method:
.PP
.Vb 2
\&    use LWP::Simple;
\&    use URI::URL;
.Ve
.PP
.Vb 3
\&    my $url = url('http://www.perl.com/cgi-bin/cpan_mod');
\&    $url->query_form(module => 'DB_File', readme => 1);
\&    $content = get($url);
.Ve
.PP
If you're using the \s-1POST\s0 method, create your own user agent and encode
the content appropriately.
.PP
.Vb 2
\&    use HTTP::Request::Common qw(POST);
\&    use LWP::UserAgent;
.Ve
.PP
.Vb 4
\&    $ua = LWP::UserAgent->new();
\&    my $req = POST 'http://www.perl.com/cgi-bin/cpan_mod',
\&                   [ module => 'DB_File', readme => 1 ];
\&    $content = $ua->request($req)->as_string;
.Ve
.Sh "如何解码或创建 web 中的 %-encoding?"
.IX Subsection "How do I decode or create those %-encodings on the web?"
If you are writing a \s-1CGI\s0 script, you should be using the \s-1CGI\s0.pm module
that comes with perl, or some other equivalent module.  The \s-1CGI\s0 module
automatically decodes queries for you, and provides an \fIescape()\fR
function to handle encoding.
.PP
The best source of detailed information on \s-1URI\s0 encoding is \s-1RFC\s0 2396.
Basically, the following substitutions do it:
.PP
.Vb 1
\&    s/([^\ew()'*~!.-])/sprintf '%%%02x', ord $1/eg;   # encode
.Ve
.PP
.Vb 1
\&    s/%([A-Fa-f\ed]{2})/chr hex $1/eg;            # decode
.Ve
.PP
However, you should only apply them to individual \s-1URI\s0 components, not
the entire \s-1URI\s0, otherwise you'll lose information and generally mess
things up.  If that didn't explain it, don't worry.  Just go read
section 2 of the \s-1RFC\s0, it's probably the best explanation there is.
.PP
\&\s-1RFC\s0 2396 also contains a lot of other useful information, including a
regexp for breaking any arbitrary \s-1URI\s0 into components (Appendix B).
.Sh "如何重定向到其他页面？"
.IX Subsection "How do I redirect to another page?"
Specify the complete \s-1URL\s0 of the destination (even if it is on the same
server). This is one of the two different kinds of \s-1CGI\s0 \*(L"Location:\*(R"
responses which are defined in the \s-1CGI\s0 specification for a Parsed Headers
script. The other kind (an absolute URLpath) is resolved internally to
the server without any \s-1HTTP\s0 redirection. The \s-1CGI\s0 specifications do not
allow relative URLs in either case.
.PP
Use of \s-1CGI\s0.pm is strongly recommended.  This example shows redirection
with a complete \s-1URL\s0. This redirection is handled by the web browser.
.PP
.Vb 1
\&      use CGI qw/:standard/;
.Ve
.PP
.Vb 2
\&      my $url = 'http://www.cpan.org/';
\&      print redirect($url);
.Ve
.PP
This example shows a redirection with an absolute URLpath.  This
redirection is handled by the local web server.
.PP
.Vb 2
\&      my $url = '/CPAN/index.html';
\&      print redirect($url);
.Ve
.PP
But if coded directly, it could be as follows (the final \*(L"\en\*(R" is
shown separately, for clarity), using either a complete \s-1URL\s0 or
an absolute URLpath.
.PP
.Vb 2
\&      print "Location: $url\en";   # CGI response header
\&      print "\en";                 # end of headers
.Ve
.Sh "如何为我的网页加上密码？"
.IX Subsection "How do I put a password on my web pages?"
要启用 web 服务器的验证，你需要配置你的 web 服务器，不同的服务器有不同的方法\-\-\-apache 与 iPlanet 不同，后者又与 \s-1IIS\s0 不同。从你的 web 服务器的文档中查找特定服务器的配置细节。
.Sh "如何用 Perl 修改我的 .htpasswd 和 .htgroup 文件?"
.IX Subsection "How do I edit my .htpasswd and .htgroup files with Perl?"
HTTPD::UserAdmin 和 HTTPD::GroupAdmin 等模组为这些档案提供了统一的物件导向介面，尽管这些档案可能以各种不同的格式储存。这些资料库可能是纯文字格式、 dbm、Berkeley DB或任何 DBI相容的资料库驱动程式 (drivers)。 HTTPD::UserAdmin支援`Basic' 和 `Digest'这两个认证模式所用的档案。以下是 一例：
.PP
.Vb 4
\&    use HTTPD::UserAdmin ();
\&    HTTPD::UserAdmin
\&          ->new(DB => "/foo/.htpasswd")
\&          ->add($username => $password);
.Ve
.Sh "如何确保用户不会在表单中输入使我的 CGI 脚本作坏事的值？"
.IX Subsection "How do I make sure users can't enter values into a form that cause my CGI script to do bad things?"
阅读 \s-1CGI\s0 Meta \s-1FAQ\s0 列出的安全索引
.PP
.Vb 1
\&        http://www.perl.org/CGI_MetaFAQ.html
.Ve
.Sh "如何解释一个邮件头？"
.IX Subsection "How do I parse a mail header?"
要使用一个快速的方法，可以这样使用 perlfunc 中的 \*(L"split\*(R" 函数：
.PP
.Vb 4
\&    $/ = '';
\&    $header = <MSG>;
\&    $header =~ s/\en\es+/ /g;      # 将延续行合并成单行
\&    %head = ( UNIX_FROM_LINE, split /^([-\ew]+):\es*/m, $header );
.Ve
.PP
但是，如果您若想保留所有 Received栏位资料的话【因 Received 栏位通常不止一个】，这个解法便不太行了。一个完整的解法是使用收录在 CPAN的 Mail::Header 模组（ MailTools 套件的一部分）。
.Sh "如何解码一个 CGI 表单？"
.IX Subsection "How do I decode a CGI form?"
使用标准模块，应该是 \s-1CGI\s0.pm。没有理由去尝试手动去做！
.PP
你大概都看过一大堆从 STDIN 读取与 $ENV{CONTENT_LENGTH} 长度相同的字节，或者获取 $ENV{QUERY_STRING} 来解码 GET。这些程序都非常糟糕。他们仅在某些时候工作。他们通常不检查 read() 的返回值，这是主要的错误。他们不处理 \s-1HEAD\s0 请求。他们不处理文件上载时的多成分表单。They don't deal
with \s-1GET/POST\s0 combinations where query fields are in more than one place.
They don't deal with keywords in the query string.
.PP
In short, they're bad hacks.  Resist them at all costs.  Please do not be
tempted to reinvent the wheel.  Instead, use the \s-1CGI\s0.pm or CGI_Lite.pm
(available from \s-1CPAN\s0), or if you're trapped in the module-free land
of perl1 .. perl4, you might look into cgi\-lib.pl (available from
http://cgi\-lib.stanford.edu/cgi\-lib/ ).
.PP
Make sure you know whether to use a \s-1GET\s0 or a \s-1POST\s0 in your form.
GETs should only be used for something that doesn't update the server.
Otherwise you can get mangled databases and repeated feedback mail
messages.  The fancy word for this is ``idempotency''.  This simply
means that there should be no difference between making a \s-1GET\s0 request
for a particular \s-1URL\s0 once or multiple times.  This is because the
\&\s-1HTTP\s0 protocol definition says that a \s-1GET\s0 request may be cached by the
browser, or server, or an intervening proxy.  \s-1POST\s0 requests cannot be
cached, because each request is independent and matters.  Typically,
\&\s-1POST\s0 requests change or depend on state on the server (query or update
a database, send mail, or purchase a computer).
.Sh "如何检测一个有效的邮件地址？"
.IX Subsection "How do I check a valid mail address?"
没有办法。至少，没有可行的办法。
.PP
如果没有寄封信到一个位址去试试看它会不会弹回来（即使是这麽做您还得面对停顿的问题），您是无法确定一个位址是否真的存在的。即使您套用 email 标头的标准规格来做检查的依据，您还是有可能会遇到问题，因为有些送得到的位址并不 符合 RFC-822（电子邮件标头的标准）的规定，但有些符合标准的位址却无法投 递。
.PP
You can use the Email::Valid or RFC::RFC822::Address which check
the format of the address, although they cannot actually tell you
if it is a deliverable address (i.e. that mail to the address
will not bounce).  Modules like Mail::CheckUser and Mail::EXPN
try to interact with the domain name system or particular
mail servers to learn even more, but their methods do not
work everywhere\-\-\-especially for security conscious administrators.
.PP
许多人试图用一个简单的正规表示式，例如 \f(CW\*(C`/^[\ew.\-]+\e@(?:[\ew\-]+\e.)+\ew+$/\*(C'\fR 来消除一些通常是无效的 email 位址。不过，这样做也把很多合格的位址给一起滤掉了，而且对测试一个位址有没有希望投递成功完全没有帮助，所以在此建议大家不要这麽做；不过您可以看看：
http://www.cpan.org/authors/Tom_Christiansen/scripts/ckaddr.gz ,
这个 script真的彻底地依据所有的 RFC规定来做检验（除了内嵌式 comments外）,同时会排除一些您可能不会想送信去的位址（如 Bill Clinton【美国总统】或您的 postmaster），然後它会确定位址中的主机名称可在 DNS中找得到。这个 script 跑起来不是很快，但至少有效。
.PP
Our best advice for verifying a person's mail address is to have them
enter their address twice, just as you normally do to change a password.
This usually weeds out typos.  If both versions match, send
mail to that address with a personal message that looks somewhat like:
.PP
.Vb 1
\&    Dear someuser@host.com,
.Ve
.PP
.Vb 5
\&    Please confirm the mail address you gave us Wed May  6 09:38:41
\&    MDT 1998 by replying to this message.  Include the string
\&    "Rumpelstiltskin" in that reply, but spelled in reverse; that is,
\&    start with "Nik...".  Once this is done, your confirmed address will
\&    be entered into our records.
.Ve
.PP
If you get the message back and they've followed your directions,
you can be reasonably assured that it's real.
.PP
A related strategy that's less open to forgery is to give them a \s-1PIN\s0
(personal \s-1ID\s0 number).  Record the address and \s-1PIN\s0 (best that it be a
random one) for later processing.  In the mail you send, ask them to
include the \s-1PIN\s0 in their reply.  But if it bounces, or the message is
included via a ``vacation'' script, it'll be there anyway.  So it's
best to ask them to mail back a slight alteration of the \s-1PIN\s0, such as
with the characters reversed, one added or subtracted to each digit, etc.
.Sh "如何解码一个 MIME/BASE64 字符串?"
.IX Subsection "How do I decode a MIME/BASE64 string?"
MIME-tools套件（可自 CPAN取得）不但可处理这个问题而且有许多其他的功能。有了这个套件，解 BASE64码就变得像这麽容易：
.PP
.Vb 2
\&    use MIME::Base64;
\&    $decoded = decode_base64($encoded);
.Ve
.PP
The MIME-Tools package (available from \s-1CPAN\s0) supports extraction with
decoding of \s-1BASE64\s0 encoded attachments and content directly from email
messages.
.PP
一个比较直接的解法是先做一点简单的转译，然後使用 unpack()这个函数的 ``u'' 格式：
.PP
.Vb 4
\&    tr#A-Za-z0-9+/##cd;                   # remove non-base64 chars
\&    tr#A-Za-z0-9+/# -_#;                  # convert to uuencoded format
\&    $len = pack("c", 32 + 0.75*length);   # compute length byte
\&    print unpack("u", $len . $_);         # uudecode and print
.Ve
.Sh "如何返回用户的邮件地址？"
.IX Subsection "How do I return the user's mail address?"
On systems that support getpwuid, the $< variable, and the
Sys::Hostname module (which is part of the standard perl distribution),
you can probably try using something like this:
.PP
.Vb 2
\&    use Sys::Hostname;
\&    $address = sprintf('%s@%s', scalar getpwuid($<), hostname);
.Ve
.PP
Company policies on mail address can mean that this generates addresses
that the company's mail system will not accept, so you should ask for
users' mail addresses when this matters.  Furthermore, not all systems
on which Perl runs are so forthcoming with this information as is Unix.
.PP
The Mail::Util module from \s-1CPAN\s0 (part of the MailTools package) provides a
\&\fImailaddress()\fR function that tries to guess the mail address of the user.
It makes a more intelligent guess than the code above, using information
given when the module was installed, but it could still be incorrect.
Again, the best way is often just to ask the user.
.Sh "如何发邮件？"
.IX Subsection "How do I send mail?"
Use the \f(CW\*(C`sendmail\*(C'\fR program directly:
.PP
.Vb 6
\&    open(SENDMAIL, "|/usr/lib/sendmail -oi -t -odq")
\&                        or die "Can't fork for sendmail: $!\en";
\&    print SENDMAIL <<"EOF";
\&    From: User Originating Mail <me\e@host>
\&    To: Final Destination <you\e@otherhost>
\&    Subject: A relevant subject line
.Ve
.PP
.Vb 4
\&    Body of the message goes here after the blank line
\&    in as many lines as you like.
\&    EOF
\&    close(SENDMAIL)     or warn "sendmail didn't close nicely";
.Ve
.PP
The \fB\-oi\fR option prevents sendmail from interpreting a line consisting
of a single dot as \*(L"end of message\*(R".  The \fB\-t\fR option says to use the
headers to decide who to send the message to, and \fB\-odq\fR says to put
the message into the queue.  This last option means your message won't
be immediately delivered, so leave it out if you want immediate
delivery.
.PP
Alternate, less convenient approaches include calling mail (sometimes
called mailx) directly or simply opening up port 25 have having an
intimate conversation between just you and the remote \s-1SMTP\s0 daemon,
probably sendmail.
.PP
Or you might be able use the \s-1CPAN\s0 module Mail::Mailer:
.PP
.Vb 1
\&    use Mail::Mailer;
.Ve
.PP
.Vb 8
\&    $mailer = Mail::Mailer->new();
\&    $mailer->open({ From    => $from_address,
\&                    To      => $to_address,
\&                    Subject => $subject,
\&                  })
\&        or die "Can't open: $!\en";
\&    print $mailer $body;
\&    $mailer->close();
.Ve
.PP
The Mail::Internet module uses Net::SMTP which is less Unix-centric than
Mail::Mailer, but less reliable.  Avoid raw \s-1SMTP\s0 commands.  There
are many reasons to use a mail transport agent like sendmail.  These
include queuing, \s-1MX\s0 records, and security.
.Sh "如何使用 MIME 来为邮件消息增加附件？"
.IX Subsection "How do I use MIME to make an attachment to a mail message?"
This answer is extracted directly from the MIME::Lite documentation.
Create a multipart message (i.e., one with attachments).
.PP
.Vb 1
\&    use MIME::Lite;
.Ve
.PP
.Vb 8
\&    ### Create a new multipart message:
\&    $msg = MIME::Lite->new(
\&                 From    =>'me@myhost.com',
\&                 To      =>'you@yourhost.com',
\&                 Cc      =>'some@other.com, some@more.com',
\&                 Subject =>'A message with 2 parts...',
\&                 Type    =>'multipart/mixed'
\&                 );
.Ve
.PP
.Vb 8
\&    ### Add parts (each "attach" has same arguments as "new"):
\&    $msg->attach(Type     =>'TEXT',
\&                 Data     =>"Here's the GIF file you wanted"
\&                 );
\&    $msg->attach(Type     =>'image/gif',
\&                 Path     =>'aaa000123.gif',
\&                 Filename =>'logo.gif'
\&                 );
.Ve
.PP
.Vb 1
\&    $text = $msg->as_string;
.Ve
.PP
MIME::Lite also includes a method for sending these things.
.PP
.Vb 1
\&    $msg->send;
.Ve
.PP
This defaults to using sendmail but can be customized to use
\&\s-1SMTP\s0 via Net::SMTP.
.Sh "如何读邮件？"
.IX Subsection "How do I read mail?"
While you could use the Mail::Folder module from \s-1CPAN\s0 (part of the
MailFolder package) or the Mail::Internet module from \s-1CPAN\s0 (part
of the MailTools package), often a module is overkill.  Here's a
mail sorter.
.PP
.Vb 1
\&    #!/usr/bin/perl
.Ve
.PP
.Vb 13
\&    my(@msgs, @sub);
\&    my $msgno = -1;
\&    $/ = '';                    # paragraph reads
\&    while (<>) {
\&        if (/^From /m) {
\&            /^Subject:\es*(?:Re:\es*)*(.*)/mi;
\&            $sub[++$msgno] = lc($1) || '';
\&        }
\&        $msgs[$msgno] .= $_;
\&    }
\&    for my $i (sort { $sub[$a] cmp $sub[$b] || $a <=> $b } (0 .. $#msgs)) {
\&        print $msgs[$i];
\&    }
.Ve
.PP
Or more succinctly,
.PP
.Vb 6
\&    #!/usr/bin/perl -n00
\&    # bysub2 - awkish sort-by-subject
\&    BEGIN { $msgno = -1 }
\&    $sub[++$msgno] = (/^Subject:\es*(?:Re:\es*)*(.*)/mi)[0] if /^From/m;
\&    $msg[$msgno] .= $_;
\&    END { print @msg[ sort { $sub[$a] cmp $sub[$b] || $a <=> $b } (0 .. $#msg) ] }
.Ve
.Sh "如何找到我的主机名/域名/IP 地址？"
.IX Subsection "How do I find out my hostname/domainname/IP address?"
长久以来许多 code都很草率地直接呼叫 `hostname` 这个程式来取得主机名。虽然这麽做很方便，但也同时增加了移植到其他平台上的困难。这是一个很典型的例子，在方便和可移植性之间作抉择，不论选哪一边，必须付出一些牺牲和代价。
.PP
Sys::Hostname这个模组（标准 perl发行的一部分）可用来取得机器的名字，然後您便可利用 gethostbyname()这个系统呼叫来找出该机的 IP位址了（假定您的 DNS 运作正常）。
.PP
.Vb 4
\&    use Socket;
\&    use Sys::Hostname;
\&    my $host = hostname();
\&    my $addr = inet_ntoa(scalar gethostbyname($host || 'localhost'));
.Ve
.PP
至少在 Unix 底下，取得 DNS网域名最简单的方法大概要算是直接从 /etc/resolv.conf 这个档案里面找。当然，这麽做的前提是 resolv.conf 这个档案的设定必须照惯例的格式，还有就是这个档案必先存在才行。
.PP
(Perl在非 Unix系统下尚需要一有效的方法来测出机器和网域名)
.Sh "如何获取一篇新闻文章或活动的新闻组？"
.IX Subsection "How do I fetch a news article or the active newsgroups?"
使用 Net::NNTP或 News::NNTPClient模组，两者皆可自 CPAN下载。这些模组让抓群组名录这类的差事变得这麽容易：
.PP
.Vb 2
\&    perl -MNews::NNTPClient
\&      -e 'print News::NNTPClient->new->list("newsgroups")'
.Ve
.Sh "如何获取/上传一个 FTP 文件?"
.IX Subsection "How do I fetch/put an FTP file?"
LWP::Simple模组（可自 CPAN下载）可以抓，但不能上传档案。 Net::FTP模组（也可自 CPAN下载）虽比较复杂，但可用来上传、也能抓档案。
.Sh "如何进行远程过程调用 RPC ?"
.IX Subsection "How can I do RPC in Perl?"
模块 \s-1DCE::RPC\s0 正在开发中 (但是还不可用)，将成为 DCE-Perl 包 (可以从 CPAN 下载) 的一部分。rpcgen 套件，可以从 CPAN/authors/id/JAKE/ 找到，是一个 \s-1RPC\s0 存根生成器，包含一个 \s-1RPC::ONC\s0 模块。
.SH "AUTHOR AND COPYRIGHT"
.IX Header "AUTHOR AND COPYRIGHT"
Copyright (c) 1997\-2002 Tom Christiansen and Nathan Torkington.
All rights reserved.
.PP
This documentation is free; you can redistribute it and/or modify it
under the same terms as Perl itself.
.PP
Irrespective of its distribution, all code examples in this file
are hereby placed into the public domain.  You are permitted and
encouraged to use this code in your own programs for fun
or for profit as you see fit.  A simple comment in the code giving
credit would be courteous but is not required.
.SH "译者"
.B 萧百龄，两只老虎工作室
