.\" auto-generated by docbook2man-spec $Revision: 1.1 $
.TH "CREATE RULE" "7" "2003-11-02" "SQL - Language Statements" "SQL Commands"
.SH NAME
CREATE RULE \- 定义一个新的重写规则

.SH SYNOPSIS
.sp
.nf
CREATE [ OR REPLACE ] RULE \fIname\fR AS ON \fIevent\fR
    TO \fItable\fR [ WHERE \fIcondition\fR ]
    DO [ INSTEAD ] { NOTHING | \fIcommand\fR | ( \fIcommand\fR ; \fIcommand\fR ... ) }
.sp
.fi
.SH "DESCRIPTION 描述"
.PP
\fBCREATE RULE\fR 定义一个适用于特定表或者视图的新规则。 CREATE OR REPLACE RULE 要么是创建一个新规则， 要么是用一个同表上的同名规则替换现有规则。
.PP
PostgreSQL规则系统允许我们在从数据库或表中更新， 插入或删除东西时定义一个其它的动作来执行。 简单说，规则就是当我们在指定的表上执行指定的动作的时候，导致一些额外的动作被执行。 另外，规则可以用另外一个命令取代某个特定的命令，或者令命令完全不被执行。 规则还用于实现表视图。我们要明白的是规则实际上只是一个命令转换机制，或者说命令宏。 这种转换发生在命令开始执行之前。如果你实际上想要一个为每个物理行独立发生的操作， 那么你可能还是要用一个触发器，而不是规则。有关规则的更多信息可以在 ``The Rule System'' 找到。
.PP
 目前，ON SELECT 规则必须是无条件的 INSTEAD 规则并且必须有一个由一条 SELECT 查询组成的动作。 因此，一条 ON SELECT 规则有效地把对象表转成视图， 它的可见内容是规则的 SELECT 查询返回的记录而不是存储在表中的内容（如果有的话）。 我们认为写一条 CREATE VIEW 命令比创建一个表然后定义一条 ON SELECT 规则在上面的风格要好。
.PP
 你可以创建一个可以更新的视图的幻觉， 方法是在视图上定义 ON INSERT，ON UPDATE，和 ON DELETE  规则（或者满足你需要的任何上述规则的子集），用合适的对其它表的更新替换在视图上更新的动作。
.PP
 如果你想在视图更新上使用条件规则，那么这里就有一个补充： 对你希望在视图上允许的每个动作，你都必须有一个无条件的 INSTEAD 规则。 如果规则是有条件的，或者它不是 INSTEAD， 那么系统仍将拒绝执行更新动作的企图，因为它认为它最终会在某种程度上在虚拟表上执行动作。 如果你想处理条件规则上的所由有用的情况，那也可以；只需要增加一个无条件的 DO INSTEAD NOTHING 规则确保系统明白它将决不会被调用来更新虚拟表就可以了。 然后把条件规则做成非 INSTEAD；在这种情况下，如果它们被触发，那么它们就增加到缺省的 INSTEAD NOTHING  动作中。
.SH "PARAMETERS 参数"
.TP
\fB\fIname\fB\fR
 创建的规则名。它必须在同一个表上的所有规则的名字中唯一。 同一个表上的同一个事件类型的规则是按照字母顺序运行的。
.TP
\fB\fIevent\fB\fR
 事件是 SELECT， UPDATE，DELETE  或 INSERT 之一。
.TP
\fB\fItable\fB\fR
 规则施用的表或者视图的名字（可以有模式修饰）。
.TP
\fB\fIcondition\fB\fR
 任意 SQL 条件表达式（返回 boolean）。 条件表达式除了引用 NEW 和 OLD 之外不能引用任何表，并且不能有聚集函数。
.TP
\fB\fIcommand\fB\fR
 组成规则动作的命令。有效的命令是 SELECT，INSERT， UPDATE，DELETE，或 NOTIFY 语句之一。
.PP
 在 condition  和 command 里， 特殊表名字 NEW 和 OLD 可以用于指向被引用表里的数值 new 在 ON INSERT 和 ON UPDATE 规则里可以指向被插入或更新的新行。 OLD 在 ON UPDATE，和 ON DELETE 规则里可以指向现存的被更新，或者删除的行。
.PP
.SH "NOTES 注意"
.PP
 为了在表上定义规则，你必须有 RULE 权限。
.PP
 有一件很重要的事情是要避免循环规则。 比如，尽管下面两条规则定义都是 PostgreSQL 可以接受的， 但一条 SELECT 命令会导致 PostgreSQL 报告一条错误信息，因为该查询循环了太多次：
.sp
.nf
CREATE RULE "_RETURN" AS
    ON SELECT TO t1
    DO INSTEAD 
	SELECT * FROM t2;

CREATE RULE "_RETURN" AS
    ON SELECT TO t2
    DO INSTEAD 
	SELECT * FROM t1;

SELECT * FROM t1;
.sp
.fi
.PP
 目前，如果一个规则包含一个 NOTIFY 查询，那么该 NOTIFY 将被无条件执行 --- 也就是说，如果规则不施加到任何行上头， 该 NOTIFY 也会被发出。比如，在
.sp
.nf
CREATE RULE notify_me AS ON UPDATE TO mytable DO NOTIFY mytable;

UPDATE mytable SET name = 'foo' WHERE id = 42;
.sp
.fi
 里，一个 NOTIFY 事件将在 UPDATE 的时候发出，不管是否有某行的 id = 42。这是一个实现的限制，将来的版本应该修补这个毛病。
.SH "COMPATIBILITY 兼容性"
.PP
\fBCREATE RULE\fR 是 PostgreSQL  语言的扩展，整个规则系统也是如此。
.SH "译者"
.B Postgresql 中文网站
.B 何伟平 <laser@pgsqldb.org>
