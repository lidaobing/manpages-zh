. mso zh.tmac
.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.14
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLNUMBER 1"
.TH PERLNUMBER 7 "2003-11-25" "perl v5.8.3" "Perl Programmers Reference Guide"
.SH "NAME"
perlnumber \- Perl 中数字的语义以及算术操作
.SH "SYNOPSIS 总览"
.IX Header "SYNOPSIS"
.Vb 7
\&    $n = 1234;              # 十进制数
\&    $n = 0b1110011;         # 二进制数
\&    $n = 01234;             # 八进制数
\&    $n = 0x1234;            # 十六进制数
\&    $n = 12.34e-56;         # 指数形式
\&    $n = "-12.34e56";       # 用字符串描述的数
\&    $n = "1234";            # 用字符串描述的数
.Ve
.SH "DESCRIPTION 描述"
.IX Header "DESCRIPTION"
这篇文章描述了Perl内部是怎样处理数的数值的。
.PP
在这里不会提到Perl的运算符重载机制，运算符重载允许用户自定义对数的操作，例如对任意大的整型数或者任意精度的浮点数进行的操作，或者一些其它的算术类型如求模操作和p\-adic操作等等。要想知道运算符重载的细节，请看重载。
.SH "Storing numbers 数值存储"
.IX Header "Storing numbers"
Per在内部能用三种方法表示数值：用“Native整型”，“Native浮点型”或是用十进制形式的字符串。其中十进制字符串可以带一个指数描述的部分，就像\f(CW"12.34e\-56"\fR。在这里术语\&\fINative\fR的含义是用于编译 perl 的 C 编译器所支持的类型。
.PP
在我们谈及整型时，\*(L"native\*(R"这个术语所包含的含义比我们谈论浮点数时要少一些。对\*(L"native\*(R"整型来说，这个术语所的含义仅仅是指整型数的可以有最大值和最小值会是2的某次方，而对\*(L"native\*(R"浮点数来说，有一条基本的限制就是它只能表示那些能用有限几位二进制小数所表示的实数。举例来说，0.9就不是\*(L"native\*(R"浮点数，因为0.9用二进制小数表示是有无穷多位的：
.PP
.Vb 1
\&  二进制0.1110011001100...
.Ve
.PP
序列 \f(CW1100\fR 将无休止的循环下去。除了这条限制以外，二进制浮点数在用指数型式表达时也存有限制。在特定的硬件条件下，浮点型的数可以存储最多53位二进制数再加上范围从\-1024到1024的指数值(译者：-1024到1024用11位二进制数，加上53等于64，就是说这里用用64位存一个浮点数）转换成十进制也就是说差不多能用16位有效数字和从\-304到304的指数值和起来表示一个浮点数。这种表示方法的一种结果就是我们不可能在不损失精度的情况下用浮点型存储像12345678901234567这样的数。
.PP
类似的，十进制字符串也只能表示有限位数的十进制数.光就字符串来言,它可以是任意长度的,没有什么关于指数或有效数字位数上的限制.(但是请意识到我们正在讨论的存放数值的那些规则.事实是你能用字符串存放很大的数值并不代表相应的数值操作能够把字符串中的所有的数位都用上.欲知详情,请看\*(L"数值运算符和数值转换\*(R"
.PP
事实上“Native整型数”存储的数值可以是带符号的，或者是不带符号的。所以很典型的，Perl中“Native整型数”可以表示的整数的范围是\-2**31..2**32\-1，这个范围对64位的整数来说是比较合适的。但这并不意味着Perl只能处理这个范围内的整数：浮点类型可以存下更大的整数。
.PP
总而言之，Perl中的数是有限位数的十进制数或者说是足够短的二进制数。
.SH "Numeric operators and numeric conversions 数值运算符和数值转换"
.IX Header "Numeric operators and numeric conversions"
就像前面说的那样，Perl可以用三种格式中的任意一种存放一个数，但是大多数运算符只能理解这三种格式中的一种。当一个数值作为参数传给一个运算符时，它将会被转换成运算符可以理解的那种格式。
.PP
可能出现的转换有下面六种：
.PP
.Vb 6
\&  native 整型        --> native 浮点型      (*)
\&  native 整型        --> 十进制形式的字符串
\&  native 浮点型 --> native 整型              (*)
\&  native 浮点型 --> decimal string              (*)
\&  十进制的字符串        --> native 整型
\&  十进制的字符串        --> native 浮点型       (*)
.Ve
.PP
这些转换按照下列的规则进行：
.IP "\(bu" 4
如果原来的数可以用要转换成的格式表述，则其值继续使用，不会改变。
.IP "\(bu" 4
如果原来的数超出了要转换成的格式所能表述的极限，则最接近极限的那个值会被用来做最后的值。（这会有信息上的损失）
.IP "\(bu" 4
如果原来的数在要转换成的格式所能表述的两个相邻的数之间，则这两个数中的一个会被用来做最后的值。（这会有信息上的损失）
.IP "\(bu" 4
在 \f(CW\*(C`native 浮点型 \-\-> native 整型\*(C'\fR 的转换中，结果的值小于等于原来的值。（因为是直接截取小数位取整的）(\fI\*(L"Rounding to zero\*(R".\fR)
.IP "\(bu" 4
如果 \f(CW\*(C`十进制的字符串 \-\-> native 整型\*(C'\fR  的转换不能在不损失信息的情况下完成，结果将会和下列的转换序列的结果一致：\f(CW\*(C`十进制的字符串 \-\-> native_浮点型 \-\-> native_整型\*(C'\fR. 特别要指出的是，尽管像 \&\f(CW"0.99999999999999999999"\fR 这样的数可能会取整成1，取整一般是倾向于0的。
.PP
\&\fB\s-1限制\s0\fR: 上面标有 \f(CW\*(C`(*)\*(C'\fR 的转换包含有C编译器的动作步骤。在特殊情况下，C编译器的一些特性或者Bugs可能会导致上述一些规则的不成立。
.SH "Flavors of Perl numeric operations 数值操作的特色"
.IX Header "Flavors of Perl numeric operations"
Perl 中带有数值参数的操作将按照四种方法处理参数：它们可能会将参数强制转换为整型，浮点型或是字符串型中的一种，或者按照操作数的格式来处理参数。在把一个数的类型强制转换成另一种特定的类型的过程中，原来存储的值不会改变。
.PP
所有需要整型数作参数的运算符会对参数进行取模的操作。比如说用32位存放整型数时会把数对2的32次方取模 (\f(CW\*(C`mod 2**32\*(C'\fR)，所以 \f(CW\*(C`sprintf "%u", \-1\*(C'\fR  的结果和 \&\f(CW\*(C`sprintf "%u", ~0\*(C'\fR 的结果是一样的。
.IP "Arithmetic operators 算术运算符" 4
.IX Item "Arithmetic operators"
二进制运算符 \f(CW\*(C`+\*(C'\fR \f(CW\*(C`\-\*(C'\fR \f(CW\*(C`*\*(C'\fR \f(CW\*(C`/\*(C'\fR \f(CW\*(C`%\*(C'\fR \f(CW\*(C`==\*(C'\fR \f(CW\*(C`!=\*(C'\fR \f(CW\*(C`>\*(C'\fR \f(CW\*(C`<\*(C'\fR
\&\f(CW\*(C`>=\*(C'\fR \f(CW\*(C`<=\*(C'\fR 以及一元运算符 \f(CW\*(C`\-\*(C'\fR \f(CW\*(C`abs\*(C'\fR and \f(CW\*(C`\-\-\*(C'\fR 
总试图将参数转换为整形。如果转换都可以无损精度地进行，并且运算也无损于精度，那么返回整数的结果。否则，参数被转换为浮点数，返回浮点数结果。转换的缓冲过程保证了整数转换不会将浮点数的零头丢掉
.IP "++" 4
\&\f(CW\*(C`++\*(C'\fR 的行为与其他操作符类似，但是如果操作数是满足 \f(CW\*(C`/^[a\-zA\-Z]*[0\-9]*\ez/\*(C'\fR 格式的字符串，将进行 perlop 中描述的字符串递增运算。
.ie n .IP "定义了 ""use integer"" 时的算术运算" 4
.el .IP "定义了 \f(CWuse integer\fR 时的算术运算" 4
.IX Item "Arithmetic operators during use integer"
在 \f(CW\*(C`use integer;\*(C'\fR 的作用范围内，几乎上面列出的所有操作符都将它们的操作数转换为整数，返回整数的结果，例外情况是 \f(CW\*(C`abs\*(C'\fR, \f(CW\*(C`++\*(C'\fR 和 \f(CW\*(C`\-\-\*(C'\fR，在这种情况下不改变行为。
.IP "Other mathematical operators 其他数学操作符" 4
.IX Item "Other mathematical operators"
类似 \f(CW\*(C`**\*(C'\fR, \f(CW\*(C`sin\*(C'\fR 和 \f(CW\*(C`exp\*(C'\fR 的操作符强制参数为浮点格式。
.IP "Bitwise operators 位操作符" 4
.IX Item "Bitwise operators"
如果不是字符串，操作数被强制转换为整型
.ie n .IP "定义了 ""use integer"" 时的位运算" 4
.el .IP "定义了 \f(CWuse integer\fR 时的位运算" 4
.IX Item "Bitwise operators during use integer"
强制参数为整型。并且，移位操作在内部使用有符号整型而不是默认的无符号数
.IP "需要整型操作数的操作符" 4
.IX Item "Operators which expect an integer"
强制操作数转换为整型。例如，在函数 \f(CW\*(C`sysread\*(C'\fR 的第三和第四个参数中，这样做是合适的。
.IP "需要字符串的操作符" 4
.IX Item "Operators which expect a string"
强制操作数为字符串格式。例如，在 \f(CW\*(C`printf "%s", $value\*(C'\fR 中，这样做是合适的。
.PP
尽管强制转换参数为特定格式不会改变已存储的数字，Perl 会记录转换的结果。特别的，尽管第一次转换会耗费一定时间，重复进行的操作不会需要重新转换。
.SH "AUTHOR 作者"
.IX Header "AUTHOR"
Ilya Zakharevich \f(CW\*(C`ilya@math.ohio\-state.edu\*(C'\fR
.PP
由 Gurusamy Sarathy <gsar@ActiveState.com> 编辑
.PP
由 Nicholas Clark <nick@ccl4.org> 更新为 5.8.0 版
.SH "SEE ALSO 参见"
.IX Header "SEE ALSO"
overload, perlop
