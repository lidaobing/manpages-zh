. mso zh.tmac
.\" auto-generated by docbook2man-spec $Revision: 1.1 $
.TH "CREATE TRIGGER" "7" "2003-11-02" "SQL - Language Statements" "SQL Commands"
.SH NAME
CREATE TRIGGER \- 定义一个新的触发器

.SH SYNOPSIS
.sp
.nf
CREATE TRIGGER \fIname\fR { BEFORE | AFTER } { \fIevent\fR [ OR ... ] }
    ON \fItable\fR [ FOR [ EACH ] { ROW | STATEMENT } ]
    EXECUTE PROCEDURE \fIfuncname\fR ( \fIarguments\fR )
.sp
.fi
.SH "DESCRIPTION 描述"
.PP
\fBCREATE TRIGGER\fR 创建一个新的触发器。 触发器将与指定表关联并且将在特定事件发生时执行声明的函数 func。
.PP
 触发器可以声明为在对记录进行操作之前（在检查约束之前和 INSERT，UPDATE  或 DELETE 执行前）或操作完成之后（在检查约束之后和完成  INSERT， UPDATE 或 DELETE 操作）触发。 如果触发器在事件之前，触发器可能略过当前记录的操作或改变被插入的（当前）记录（只对 INSERT 和 UPDATE 操作有效）。 如果触发器在事件之后，所有更改，包括最后的插入， 更新或删除对触发器都是"可见"的。
.PP
 一个 FOR EACH ROW 执行指定操作的触发器为操作修改的每一行都调用一次。比如，一个影响 10 行的 DELETE 将导致任何在目标关系上的 ON DELETE 触发器独立调用 10 次， 每个被删除的行一次。相比之下，一个为指定操作 FOR EACH STATEMENT  的触发器只是为任何操作执行一次，不管有多少行被修改。 （特别是，一个修改零行的操作仍然会导致任何合适的 FOR EACH STATEMENT 触发器的执行。）
.PP
 如果多个同类型的触发器为同样事件做了定义， 那么它们将按照字母顺序被激活。
.PP
SELECT 并不更改任何行，因此你不能创建 SELECT 触发器。这种场合下规则和视图更合适些。
.PP
 请参考 Part V ``Triggers'' 获取更多信息。
.SH "PARAMETERS 参数"
.TP
\fB\fIname\fB\fR
 赋予新触发器的名称。它必需和任何作用于同一表的触发器不同。
.TP
\fBBEFORE\fR
.TP
\fBAFTER\fR
 决定该函数是在事件之前还是之后调用。
.TP
\fB\fIevent\fB\fR
INSERT，DELETE 或 UPDATE 其中之一。 它声明击发触发器的事件。多个事件可以用 OR 声明。
.TP
\fB\fItable\fB\fR
触发器作用的表名称（可以用模式修饰）。 
.TP
\fBFOR EACH ROW\fR
.TP
\fBFOR EACH STATEMENT\fR
 这些选项声明触发器过程是否为触发器事件影响的每个行触发一次， 还是只为每条 SQL 语句触发一次。如果都没有声明， FOR EACH STATEMENT 是缺省。
.TP
\fB\fIfunc\fB\fR
一个用户提供的函数，它声明为不接受参数并且返回 trigger 类型。 
.TP
\fB\fIarguments\fB\fR
 一个可选的用逗号分隔的参数列表，它将在触发器执行的时候提供给函数， 这些参数是文本字串常量。也可以在这里写简单的名字和数值常量，但是它们会被转换成字串。 请检查实现语言中关于如何在触发器函数中访问触发器参数的描述； 这些参数可能和普通的函数参数不同。
.SH "NOTES 注意"
.PP
 要在一个表上创建一个触发器，用户必需在该表上有 TRIGGER 权限。
.PP
 在 PostgreSQL 版本 7.3 以前， 我们必须把触发器函数声明为返回占位类型 opaque， 而不是 trigger。为了支持装载老的转储文件， CREATE TRIGGER 将接受一个声明为返回 opaque 的函数， 但是它将发出一条 NOTICE 并且把函数声明的返回类型改成 trigger。
.PP
 用 DROP TRIGGER [\fBdrop_trigger\fR(7)] 获取如何删除触发器的信息。
.SH "EXAMPLES 例子"
.PP
Section 33.4 ``Triggers'' 包含一个完整的例子。
.SH "COMPATIBILITY 兼容性"
.PP
\fBCREATE TRIGGER\fR 里的 CREATE TRIGGER 语句实现了一个 SQL99 标准的子集。 （SQL92 里没有触发器） 目前仍然缺少下面的功能∶
.TP 0.2i
\(bu
SQL99 允许触发器为指定的字段的更新进行触发（也就是说，AFTER UPDATE OF col1, col2）。
.TP 0.2i
\(bu
SQL99 允许你为 "old" 和 "new" 行或者表定义别名，用于定义触发器的动作（也就是说， CREATE TRIGGER ... ON tablename REFERENCING OLD ROW AS somename NEW ROW AS othername ...)。因为 PostgreSQL  允许触发器过程以任意数量的用户定义语言进行书写，所以访问数据的工作是用和语言相关的方法实现的。
.TP 0.2i
\(bu
PostgreSQL 只允许为触发的动作执行存储的过程。SQL99 允许执行一些其他的 SQL 命令， 比如那 CREATE TABLE 作为触发器动作。 这个限止并不难绕开，只要创建一个执行这些命令的存储过程即可。
.PP
.PP
SQL99 要求多个触发器应该以创建的时间顺序执行。 PostgreSQL 采用的是按照名字顺序， 我们认为这样更加方便。
.PP
 用 OR 给一个触发器声明多个动作是 PostgreSQL  对标准的扩展。
.SH "SEE ALSO 参见"
CREATE FUNCTION [\fBcreate_function\fR(7)], ALTER TRIGGER [\fBalter_trigger\fR(l)], DROP TRIGGER [\fBdrop_trigger\fR(l)]
.SH "译者"
.B Postgresql 中文网站
.B 何伟平 <laser@pgsqldb.org>
