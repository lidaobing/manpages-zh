. mso zh.tmac
.\" auto-generated by docbook2man-spec $Revision: 1.1 $
.TH "FETCH" "7" "2003-11-02" "SQL - Language Statements" "SQL Commands"
.SH NAME
FETCH \- 用游标从查询中抓取行

.SH SYNOPSIS
.sp
.nf
FETCH [ \fIdirection\fR { FROM | IN } ] \fIcursorname\fR

where \fIdirection\fR can be empty or one of:

    NEXT
    PRIOR
    FIRST
    LAST
    ABSOLUTE \fIcount\fR
    RELATIVE \fIcount\fR
    \fIcount\fR
    ALL
    FORWARD
    FORWARD \fIcount\fR
    FORWARD ALL
    BACKWARD
    BACKWARD \fIcount\fR
    BACKWARD ALL
.sp
.fi
.SH "DESCRIPTION 描述"
.PP
\fBFETCH\fR 使用游标检索行。
.PP
 一个游标有一个由 FETCH 使用的相关联的位置。 游标得位置可以在查询结果的第一行之前，或者在结果中的任意行， 或者在结果的最后一行之后。在创建完之后，游标是放在第一行之前的。 在抓取了一些行之后，游标放在检索到的最后一行上。如果 FETCH  抓完了所有可用行，那么它就停在最后一行后面，或者在向前抓去的情况下是停在第一行前面。 FETCH ALL 或者 FETCH BACKWARD ALL  将总是把游标的位置放在最后一行或者在第一行前面。
.PP
NEXT, PRIOR, FIRST,
LAST, ABSOLUTE, RELATIVE 形式在恰当地 移动游标之后抓取一个行。如果没有数据行了，那么返回一个空的结果， 那么游标就会停在查询结果的最后一行之后或者在第一行之前。
.PP
FORWARD 和 BACKWARD 形式在向前或者向后移动的过程中抓取指定的行数， 然后把游标定位在最后返回的行上（或者是，如果 count  大于可用的行数，在所有行之前或之后。）
.PP
RELATIVE 0，FORWARD 0，和 BACKWARD 0  都要求在不移动游标的前提下抓取当前行－－－也就是重新抓取最近刚刚抓取过的行。 除非游标定位在第一行之前或者最后一行之后，这个动作都应该成功，而在那两种情况下，不返回任何行。
.SH "PARAMETERS 参数"
.TP
\fB\fIdirection\fB\fR
\fIdirection\fR 定义抓取的方向和抓取的行数。它可以是下述之一：
.RS
.TP
\fBNEXT\fR
 抓取下一行。 direction  省略时这是缺省值。
.TP
\fBPRIOR\fR
 抓取前面一行。
.TP
\fBFIRST\fR
 抓取查询的第一行（和 ABSOLUTE 1 相同）。
.TP
\fBLAST\fR
 抓取查询的最后一行（和 ABSOLUTE -1 相同）。
.TP
\fBABSOLUTE \fIcount\fB\fR
 抓取查询中第 count 行， 或者，如果 count < 0， 从查询结果末尾抓取第abs(count)行。 如果count 超出了范围，那么定位在第一行之前和最后一行之后的位置； 特别是 ABSOLUTE 0 定位在第一行之前。
.TP
\fBRELATIVE \fIcount\fB\fR
抓取随后的第 count 行， 或者，如果 count < 0 的时候， 抓取前面的第 abs(count) 行。 如果有数据的话，RELATIVE 0 重新抓取当前行。
.TP
\fB\fIcount\fB\fR
 抓取下面的 count 行 （和 FORWARD count 一样）。
.TP
\fBALL\fR
 抓取所有剩余的行（和 FORWARD ALL 一样）。
.TP
\fBFORWARD\fR
 抓取下面一行（和 NEXT）一样。
.TP
\fBFORWARD \fIcount\fB\fR
 抓取下面 count 行。 FORWARD 0 重新抓取当前行。
.TP
\fBFORWARD ALL\fR
 抓取所有剩余行。
.TP
\fBBACKWARD\fR
 抓取前面一行（和 PRIOR 一样）。
.TP
\fBBACKWARD \fIcount\fB\fR
 抓取前面 count 行（向后扫描）。 BACKWARD 0 重新抓取当前行。
.TP
\fBBACKWARD ALL\fR
 抓取所有前面的行（向后扫描）。
.RE
.PP
.TP
\fB\fIcount\fB\fR
\fIcount\fR 可能是一个有符号的整数常量，决定要抓取的行数和方向。 对于 FORWARD 和 BACKWARD 的情况，声明一个带负号的 count  等效于改变 FORWARD 和 BACKWARD 的方向。
.TP
\fB\fIcursorname\fB\fR
 一个打开的游标的名称。
.SH "OUTPUTS 输出"
.PP
 成功完成时，一个 FETCH 命令返回一个形如下面的标记
.sp
.nf
FETCH \fIcount\fR
.sp
.fi
 这里的 count 是抓取的行数（可能是零）。 请注意在 psql 里，命令标签实际上不会显示， 因为 psql 用抓取的行数取代了。
.SH "NOTES 注意"
.PP
 如果你想使用 FETCH NEXT 之外的任何 FETCH 的变种， 或者是带负数计数的 FETCH FORWARD。那么定义游标的时候应该带着 SCROLL 选项。 对于简单的查询，PostgreSQL 会允许那些没有带 SCROLL 选项定义的游标也可以反向抓取， 但是我们最好不要依赖这个行为。 如果游标定义了 NO SCROLL，那么不允许反向抓取。
.PP
ABSOLUTE 抓取不会比用相对位移移动到需要的数据行更快： 因为下层的实现必须遍历所有中间的行。负数的绝对抓取甚至更糟糕： 查询必须一直读到结尾才能找到最后一行，然后从那里开始反向遍历。 不过，回退到查询开头（就像 FETCH ABSOLUTE 0）很快。
.PP
 在游标中更新数据还不被 PostgreSQL 支持。
.PP
DECLARE [\fBdeclare\fR(7)]
语句用于定义一个游标。使用
MOVE [\fBmove\fR(7)]
语句来改变游标位置而不检索数据。
.SH "EXAMPLES 例子"
.PP
 下面的例子用一个游标跨过一个表。
.sp
.nf
BEGIN WORK;

-- 建立一个游标：
DECLARE liahona SCROLL CURSOR FOR SELECT * FROM films;

-- 抓取头 5 行到游标 liahona 里：
FETCH FORWARD 5 FROM liahona;

 code  |          title          | did | date_prod  |   kind   |  len
-------+-------------------------+-----+------------+----------+-------
 BL101 | The Third Man           | 101 | 1949-12-23 | Drama    | 01:44
 BL102 | The African Queen       | 101 | 1951-08-11 | Romantic | 01:43
 JL201 | Une Femme est une Femme | 102 | 1961-03-12 | Romantic | 01:25
 P_301 | Vertigo                 | 103 | 1958-11-14 | Action   | 02:08
 P_302 | Becket                  | 103 | 1964-02-03 | Drama    | 02:28

-- 抓取前面行：
FETCH PRIOR FROM liahona;

 code  |  title  | did | date_prod  |  kind  |  len
-------+---------+-----+------------+--------+-------
 P_301 | Vertigo | 103 | 1958-11-14 | Action | 02:08

-- 关闭游标并提交事务：
CLOSE liahona;
COMMIT WORK;
.sp
.fi
.SH "COMPATIBILITY 兼容性"
.PP
SQL 标准定义的 FETCH 只用于嵌入式环境下。 这里描述的 FETCH 变种是把结果数据像 SELECT  结果那样返回，而不是把它放在宿主变量里。除了这点之外，FETCH 和 SQL 标准完全向上兼容。
.PP
 涉及 FORWARD 和 BACKWARD 的 FETCH 形式 （包括 FETCH count 和 FETCH ALL 的形式，这个时候 FORWARD 是隐含的）是 PostgreSQL  的扩展。
.PP
 SQL 标准只允许游标前面有 FROM， 用 IN 是一种扩展。
.SH "译者"
.B Postgresql 中文网站
.B 何伟平 <laser@pgsqldb.org>
