.\" auto-generated by docbook2man-spec $Revision: 1.1 $
.TH "CREATE VIEW" "7" "2003-11-02" "SQL - Language Statements" "SQL Commands"
.SH NAME
CREATE VIEW \- 定义一个视图

.SH SYNOPSIS
.sp
.nf
CREATE [ OR REPLACE ] VIEW \fIname\fR [ ( \fIcolumn_name\fR [, ...] ) ] AS \fIquery\fR
.sp
.fi
.SH "DESCRIPTION 描述"
.PP
\fBCREATE VIEW\fR 定义一个查询的视图。 这个视图不是物理上实际存在（于磁盘）的。具体的说，自动生成一个改写索引规则（一个 ON SELECT 规则）的查询用以支持在视图上的检索。
.PP
\fBCREATE OR REPLACE VIEW\fR 类似，不过是如果一个同名的视图已经存在，那么就替换它。 你只能用一个生成相同字段的新查询替换一个视图（也就是说，同样字段名和数据类型）。
.PP
 如果给出了一个模式名（比如，CREATE VIEW myschema.myview ...），那么该视图是在指定的模式中创建的。 否则它是在当前模式中创建的。 该视图名字必需和同一模式中任何其它视图，表，序列或者索引的名字不同。
.SH "PARAMETERS 参数"
.TP
\fB\fIname\fB\fR
 所要创建的视图名称（可以有模式修饰）。
.TP
\fB\fIcolumn_name\fB\fR
 一个可选的名字列表，用于当作视图的字段名。如果没有给出， 字段名取自查询。
.TP
\fB\fIquery\fB\fR
 一个将为视图提供行和列的查询（也就是一条 SELECT 语句）。

 请参阅 SELECT [\fBselect\fR(7)] 获取有效查询的更多信息。
.SH "NOTES 注意"
.PP
 目前，视图是只读的：系统将不允许在视图上插入，更新，或者删除数据。 你可以通过在视图上创建把插入等动作重写为向其它表做合适操作的规则来实现可更新视图的效果。 更多信息详见
CREATE RULE [\fBcreate_rule\fR(7)].
.PP
 使用 DROP VIEW 语句删除视图
.PP
 请注意视图字段的名字和类型不一定是你们期望的那样。比如，
.sp
.nf
CREATE VIEW vista AS SELECT 'Hello World';
.sp
.fi
 在两个方面很糟糕：字段名缺省是 ?column?，并且字段的数据类型缺省是 unknown。 如果你想视图的结果是一个字串文本，那么用类似下面这样的东西
.sp
.nf
CREATE VIEW vista AS SELECT text 'Hello World' AS hello;
.sp
.fi
.PP
 对视图引用的表的访问的权限由视图的所有者决定。 不过，在视图里调用的函数当作他们直接从使用视图的查询里调用看待。 因此，视图的用户必须有使用视图调用的所有函数的权限。
.SH "EXAMPLES 例子"
.PP
 创建一个由所有喜剧电影组成的视图：
.sp
.nf
CREATE VIEW comedies AS
    SELECT *
    FROM films
    WHERE kind = 'Comedy';
.sp
.fi
.SH "COMPATIBILITY 兼容性"
.PP
 SQL 标准为 CREATE VIEW 声明了一些附加的功能：
.sp
.nf
CREATE VIEW \fIname\fR [ ( \fIcolumn\fR [, ...] ) ]
    AS query
    [ WITH [ CASCADE | LOCAL ] CHECK OPTION ]
.sp
.fi
.PP
 完整的SQL命令可选的子句是：
.TP
\fBCHECK OPTION\fR
 这个选项用于可更新视图。 所有对视图的INSERT和UPDATE都要经过视图定义条件的校验。 （也就是说，新数据应该可以通过视图看到。）如果没有通过校验，更新将被拒绝。
.TP
\fBLOCAL\fR
 对这个视图进行完整性检查。
.TP
\fBCASCADE\fR
 对此视图和任何相关视图进行完整性检查。 在既没有声明 CASCADE 也没有声明 LOCAL 时，假设为 CASCADE。
.PP
.PP
\fBCREATE OR REPLACE VIEW\fR 是 PostgreSQL 的扩展。
.SH "译者"
.B Postgresql 中文网站
.B 何伟平 <laser@pgsqldb.org>
