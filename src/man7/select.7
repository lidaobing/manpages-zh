. mso zh.tmac
.\" auto-generated by docbook2man-spec $Revision: 1.1 $
.TH "SELECT" "7" "2003-11-02" "SQL - Language Statements" "SQL Commands"
.SH NAME
SELECT \- 从表或视图中取出若干行

.SH SYNOPSIS
.sp
.nf
SELECT [ ALL | DISTINCT [ ON ( \fIexpression\fR [, ...] ) ] ]
    * | \fIexpression\fR [ AS \fIoutput_name\fR ] [, ...]
    [ FROM \fIfrom_item\fR [, ...] ]
    [ WHERE \fIcondition\fR ]
    [ GROUP BY \fIexpression\fR [, ...] ]
    [ HAVING \fIcondition\fR [, ...] ]
    [ { UNION | INTERSECT | EXCEPT } [ ALL ] \fIselect\fR ]
    [ ORDER BY \fIexpression\fR [ ASC | DESC | USING \fIoperator\fR ] [, ...] ]
    [ LIMIT { \fIcount\fR | ALL } ]
    [ OFFSET \fIstart\fR ]
    [ FOR UPDATE [ OF \fItable_name\fR [, ...] ] ]

where \fIfrom_item\fR can be one of:

    [ ONLY ] \fItable_name\fR [ * ] [ [ AS ] \fIalias\fR [ ( \fIcolumn_alias\fR [, ...] ) ] ]
    ( \fIselect\fR ) [ AS ] \fIalias\fR [ ( \fIcolumn_alias\fR [, ...] ) ]
    \fIfunction_name\fR ( [ \fIargument\fR [, ...] ] ) [ AS ] \fIalias\fR [ ( \fIcolumn_alias\fR [, ...] | \fIcolumn_definition\fR [, ...] ) ]
    \fIfunction_name\fR ( [ \fIargument\fR [, ...] ] ) AS ( \fIcolumn_definition\fR [, ...] )
    \fIfrom_item\fR [ NATURAL ] \fIjoin_type\fR \fIfrom_item\fR [ ON \fIjoin_condition\fR | USING ( \fIjoin_column\fR [, ...] ) ]
.sp
.fi
[Comment: FIXME: This last syntax is incorrect if the join type is an
INNER or OUTER join (in which case one of NATURAL, ON ..., or USING
\&... is mandatory, not optional). What's the best way to fix
this?]
.SH "DESCRIPTION 描述"
.PP
\fBSELECT\fR 将从一个或更多表中返回记录行。 SELECT 通常的处理如下：
.IP 1. 
 计算列出在 FROM 中的所有元素。（FROM 中的每个元素都是一个真正的或者虚拟的表。）如果在 FROM 列表里声明了多过一个元素，那么他们就交叉连接在一起。（参阅下面的 FROM Clause [\fBselect\fR(7)] ）。
.IP 2. 
 如果声明了 WHERE 子句，那么在输出中消除所有 不满足条件的行。（参阅下面的 WHERE Clause [\fBselect\fR(7)] ）。
.IP 3. 
 如果声明了 GROUP BY 子句，输出就分成匹配一个或多个数值的不同组里。 如果出现了 HAVING 子句，那么它消除那些不满足给出条件的组。（参阅下面的
GROUP BY Clause [\fBselect\fR(7)] 和
HAVING Clause [\fBselect\fR(7)] ）。
.IP 4. 
 使用 UNION，INTERSECT， 和 EXCEPT，我们可以把多个 SELECT  语句的输出合并成一个结果集。UNION 操作符返回在两个结果集或者其中一个中的行， INTERSECT 操作符返回严格地在两个结果集中都有的行。 EXCEPT 操作符返回在第一个结果集中，但是不在第二个结果集中的行。不管哪种情况， 重复的行都被删除，除非声明了 ALL。（参阅下面的
UNION Clause [\fBselect\fR(7)], INTERSECT Clause [\fBselect\fR(l)], 和
EXCEPT Clause [\fBselect\fR(7)] ）。
.IP 5. 
 实际输出行的时候，SELECT 先为每个选出的行计算输出表达式 （参阅下面的
SELECT List [\fBselect\fR(7)] ）。
.IP 6. 
 如果声明了 ORDER BY 子句，那么返回的行是按照指定的顺序排序的。 如果没有给出 ORDER BY，那么数据行是按照系统认为可以最快生成的方法给出的。 （参阅下面的 
ORDER BY Clause [\fBselect\fR(7)] ）。
.IP 7. 
 如果给出了 LIMIT 或者 OFFSET  子句，那么 SELECT 语句只返回结果行的一个子集。（参阅下面的 LIMIT Clause [\fBselect\fR(7)] ）。
.IP 8. 
DISTINCT 从结果中删除那些重复的行。 DISTINCT ON 删除那些匹配所有指定表达式的行。 ALL （缺省）将返回所有候选行，包括重复的。 （参阅下面的 DISTINCT Clause [\fBselect\fR(7)] ）。
.IP 9. 
FOR UPDATE 子句导致 SELECT  语句对并发的更新锁住选定的行。（参阅下面的 FOR UPDATE Clause [\fBselect\fR(7)] ）。
.PP
.PP
 你必须有 SELECT 权限用来从表中读取数值。 使用 FOR UPDATE 还要求 UPDATE 权限。
.SH "PARAMETERS 参数"
.SS "FROM 子句"
.PP
FROM 子句为 SELECT 声明一个或者多个源表。 如果声明了多个源表，那么结果就是所有源表的笛卡儿积（交叉连接）。 但是通常我们会添加一些条件，把返回行限制成笛卡儿积的一个小的结果集。
.PP
FROM-子句可以包括：
.TP
\fB\fItable_name\fB\fR
 一个现存的表或视图的名字（可以有模式修饰）。 如果声明了ONLY，则只扫描该表。 如果没有声明ONLY，该表和所有其派生表（如果有的话）都被扫描。 可以在表名后面跟一个*来表示扫所有其后代表， 但在目前的版本里，这是缺省特性。 （在 PostgreSQL 7.1 以前的版本里，ONLY是缺省特性。） 缺省的特性可以通过修改配置选项 sql_interitance 来改变。
.TP
\fB\fIalias\fB\fR
 为那些包含别名的 FROM 项目取的别名。别名用于缩写或者在自连接中消除歧义（自连接里，同一个表扫描了多次）。 如果提供了别名，那么它就会完全隐藏表或者函数的实际名字； 比如，如果给出 FROM foo AS f，那么 SELECT  剩下的东西必须吧这个 FROM 项以 f 而不是 foo 引用。如果写了别名， 我们也可以提供一个字段别名列表，这样可以替换表中一个或者多个字段的名字。
.TP
\fB\fIselect\fB\fR
 一个子 SELECT 在 FROM 子句里出现的。 它的输出作用好象是为这条 SELECT 命令在其生存期里创建一个临时表。 请注意这个子 SELECT 必须用园括弧包围。 并且必须给它加别名。
.TP
\fB\fIfunction_name\fB\fR
 函数调用可以出现在 FROM 子句里。 （对于那些返回结果集的函数特别有用，但是任何函数都能用。） 这么做就好像在这个 SELECT 命令的生命期中， 把函数的输出创建为一个临时表一样。我们也可以使用别名。如果写了别名， 我们还可以写一个字段别名列表，为函数返回的复合类型的一个或多个属性提供名字替换。 如果函数定义为了 record 数据类型， 那么必须出现一个 AS 关键字或者别名，后面跟着一个字段定义列表， 形如：( column_name data_type [, ... ])。 这个字段定义列表必须匹配函数返回的字段的实际数目和类型。
.TP
\fB\fIjoin_type\fB\fR
.RS
.TP 0.2i
\(bu
[ INNER ] JOIN
.TP 0.2i
\(bu
LEFT [ OUTER ] JOIN
.TP 0.2i
\(bu
RIGHT [ OUTER ] JOIN
.TP 0.2i
\(bu
FULL [ OUTER ] JOIN
.TP 0.2i
\(bu
CROSS JOIN
.RE
.PP
 之一。 就 INNER 和 OUTER 连接类型， 我们必须声明一个连接条件，也就是说一个 NATURAL， ON join_condition， 或者 USING (join_column [, ...])。 见下文获取它们的含义，对于 CROSS JOIN，这些子句都不能出现。

 一个 JOIN 子句，组合了两个 FROM 项。 必要时使用圆括弧以决定嵌套的顺序。 如果没有圆括弧，JOIN 的嵌套从左向右。 在任何情况下，JOIN 都比逗号分隔的 FROM 项绑定得更紧。

CROSS JOIN 和 INNER JOIN
生成一个简单的笛卡儿积，和你在 FROM 的顶层列出两个项的结果相同。 CROSS JOIN 等效于 INNER JOIN ON (true)， 也就是说，没有被条件删除的行。这种连接类型只是符号上的方便， 因为它们和你用简单的 FROM 和 WHERE 干的事情是一样的。

LEFT OUTER JOIN 返回有条件的笛卡儿积（也就是说， 所有组合出来的行都通过了连接条件）中的行，加上左手边的表中没有对应的右手边表的行可以一起匹配通过连接条件的那些行。 这样的左手边的行扩展成连接生成表的全长，方法是在那些右手边表对应的字段位置填上空。请注意，只有在决定那些行是匹配的时候， 之计算 JOIN 子句自己的条件。外层的条件是在这之后施加的。

 对应的是，RIGHT OUTER JOIN 返回所有连接出来的行， 加上每个不匹配的右手边行（左边用空值扩展）。这只是一个符号上的便利，因为我们总是可以把它转换成一个 LEFT OUTER JOIN， 只要把左边和右边的输入对掉一下即可。

FULL OUTER JOIN 返回所有连接出来的行，加上每个不匹配的左手边的行（右边用空值扩展）， 加上每个不匹配的右手边的行（左边用空值扩展）。
.TP
\fBON \fIjoin_condition\fB\fR
\fIjoin_condition\fR 是一个表达式， 生成类型为 boolean 的结果（类似WHERE 子句）， 表示连接中那些行被认为是匹配的。
.TP
\fBUSING (\fIjoin_column\fB [, ...])\fR
 一个形如 USING ( a, b, ... ) 的子句， 是ON left_table.a = right_table.a AND left_table.b = right_table.b ...  的缩写。同样，USING 蕴涵着：每对等效字段中只有一个包含在连接输出中，而不是两个都输出的意思。
.TP
\fBNATURAL\fR
NATURAL 是一个 USING 列表的缩写，这个列表说的是两个表中同名的的字段。
.PP
.SS "WHERE 子句"
.PP
 可选的 WHERE 条件有如下常见的形式：
.sp
.nf
WHERE \fIcondition\fR
.sp
.fi
 这里 condition  可以是任意生成类型为 boolean 的表达式。 任何不满足这个条件的行都会从输出中删除。如果一个行的数值替换到条件的引用中计算出来的条件为真，那么该行就算满足条件。
.SS "GROUP BY 子句"
.PP
 可选的 GROUP BY 子句的一般形式
.sp
.nf
GROUP BY \fIexpression\fR [, ...]
.sp
.fi
.PP
GROUP BY 将把所有在组合了的表达式上共享同样的值的行压缩成一行。 expression 可以是一个输入字段名字， 或者是一个输入字段（SELECT 列表）的序号，或者也可以是任意从输入字段值形成的任意表达式。 在有歧义的情况下，一个 GROUP BY 的名字将被解释成输入字段的名字，而不是输出字段的名字。
.PP
 如果使用了聚集函数，那么就会对组成一组的所有行进行计算，为每个组生成一个独立的值（而如果没有 GROUP BY， 那么聚集对选出来的所有行计算出一个值）。如果出现了 GROUP BY， 那么 SELECT 列表表达式中再引用那些没有分组的字段就是非法的， 除非放在聚集函数里，因为对于未分组的字段，可能会返回多个数值。
.SS "HAVING 子句"
.PP
 可选的 HAVING 子句有如下形式：
.sp
.nf
HAVING \fIcondition\fR
.sp
.fi
 这里 condition  和为 WHERE 子句里声明的相同。
.PP
HAVING 去除了一些不满足条件的组行。 HAVING 与 WHERE 不同： WHERE 在使用 GROUP BY  之前过滤出单独的行，而 HAVING 过滤由 GROUP BY 创建的行。 在 condition 里引用的每个字段都必须无歧义地引用一个分组的行，除非引用出现在一个聚集函数里。
.SS "UNION 子句"
.PP
UNION 子句的一般形式是：
.sp
.nf
\fIselect_statement\fR UNION [ ALL ] \fIselect_statement\fR
.sp
.fi
 这里 \fIselect_statement\fR 是任意没有 ORDER BY，LIMIT，或者 FOR UPDATE 子句的 SELECT语句。 （如果用圆括弧包围，ORDER BY 和 LIMIT 可以附着在子表达式里。 如果没有圆括弧，这些子句将交给 UNION 的结果使用， 而不是给它们右手边的输入表达式。）
.PP
UNION 操作符计算那些涉及到的所有 SELECT 语句返回的行的结果联合。 一个行如果至少在两个结果集中的一个里面出现，那么它就会在这两个结果集的集合联合中。 两个做为 UNION 直接操作数的SELECT必须生成相同数目的字段， 并且对应的字段必须有兼容的数据类型。
.PP
 缺省地，UNION 的结果不包含任何重复的行，除非声明了 ALL 子句。 ALL 制止了消除重复的动作。
.PP
 同一SELECT语句中的多个 UNION 操作符是从左向右计算的， 除非用圆括弧进行了标识。
.PP
 目前，FOR UPDATE 不能在 UNION 的结果或输入中声明。
.SS "INTERSECT 子句"
.PP
INTERSECT 子句的一般形式是：
.sp
.nf
\fIselect_statement\fR INTERSECT [ ALL ] \fIselect_statement\fR
.sp
.fi
\fIselect_statement\fR 是任何不带 ORDER BY， LIMIT，或者 FOR UPDATE 子句的 SELECT 语句。
.PP
 INTERSECT 计算涉及的 SELECT 语句返回的行的集合交集。 如果一个行在两个结果集中都出现，那么它就在两个结果集的交集中。
.PP
 NTERSECT 的结果不包含任何重复行，除非你声明了 ALL 选项。 用了 ALL 以后，一个在左手边的表里有 m 个重复而在右手边表里有 n 个重复的行将出现 min(m,n) 次。
.PP
 除非用圆括号指明顺序， 同一 SELECT 语句中的多个 INTERSECT 操作符是从左向右计算的。 INTERSECT 比 UNION 绑定得更紧 --- 也就是说 A UNION B INTERSECT C 将读做 A UNION (B INTERSECT C)，除非你用圆括弧声明。
.SS "EXCEPT 子句"
.PP
EXCEPT 子句有如下的通用形式：
.sp
.nf
\fIselect_statement\fR EXCEPT [ ALL ] \fIselect_statement\fR
.sp
.fi
 这里 fIselect_statement\fR 是任何没有 ORDER BY，LIMIT，或者 FOR UPDATE  子句的 SELECT 表达式。
.PP
EXCEPT 操作符计算存在于左边SELECT  语句的输出而不存在于右边语句输出的行。
.PP
EXCEPT 的结果不包含任何重复的行，除非声明了 ALL 选项。 使用 ALL 时，一个在左手边表中有 m 个重复而在右手边表中有 n 个重复的行将出现 max(m-n,0) 次。
.PP
 除非用圆括弧指明顺序，同一 SELECT 语句中的多个 EXCEPT 操作符是从左向右计算的。 EXCEPT 和 UNION 绑定级别相同。
.SS "SELECT 列表"
.PP
\fBSELECT\fR 列表（在关键字 SELECT 和 FROM) 之间的东西）声明一个表达式，这个表达式形成 SELECT 语句的输出行。这个表达式可以（通常也的确是）引用那些在 FROM 子句里计算的字段。 通过使用 AS output_name， 我们可以为一个输出行声明另外一个名字。这个名字主要用做显示该行的标签。 它也可以在 ORDER BY 和 GROUP BY 子句里当作字段值的引用， 但是不能在 WHERE 或者 HAVING 子句里这么用；在那里，你必须写出表达式。
.PP
 除了表达式之外，我们也可以在输出列表上写一个 * 表示选出的行的所有字段的缩写。同样，我们可以写 \fItable_name.\fR*  作为来自某个特定表的字段的缩写。
.SS "ORDER BY 子句"
.PP
 可选的 ORDER BY 子句有下面的一般形式：
.sp
.nf
ORDER BY \fIexpression\fR [ ASC | DESC | USING \fIoperator\fR ] [, ...]
.sp
.fi
\fIexpression\fR 可以是一个输出字段（SELECT 列表）的名字或者序号， 或者也可以是用输入字段的数值组成的任意表达式。
.PP
ORDER BY 子句导致结果行根据指定的表达式进行排序。 如果根据最左边的表达式，两行的结果相同，那么就根据下一个表达式进行比较， 依此类推。如果对于所有声明的表达式他们都相同，那么以随机顺序返回。
.PP
 序数指的是列/字段按顺序（从左到右）的位置。 这个特性让我们可以对没有唯一名称的列/字段进行排序。 这一点从来不是必须的， 因为总是可以通过 AS 子句给一个要计算的列/字段赋予一个名称。
.PP
 在 ORDER BY 里还可以使用任意表达式， 包括那些没有出现在SELECT结果列表里面的字段。 因此下面的语句现在是合法的：
.sp
.nf
SELECT name FROM distributors ORDER BY code;
.sp
.fi
 这个特性的一个局限就是应用于 UNION，INTERSECT， 或者 EXCEPT 查询的 ORDER BY 子句只能在一个输出字段名或者数字上声明，而不能在一个表达式上声明。
.PP
 请注意如果一个 ORDER BY 表达式是一个简单名称， 同时匹配结果字段和输入字段， ORDER BY 将把它解释成结果字段名称。 这和 GROUP BY 在同样情况下做的选择正相反。 这样的不一致是由 SQL 标准强制的。
.PP
 我们可以给 ORDER BY 子句里每个列/字段加一个关键字 DESC （降序）或 ASC（升序）。如果不声明， ASC 是缺省。 我们还可以在 USING 子句里声明一个排序操作符来实现排序。 ASC 等效于使用 USING < 而 DESC 等效于使用 USING >。
(But the creator of a user-defined data type can define exactly what the
default sort ordering is, and it might correspond to operators with other
names.)
.PP
 在一个域里，空值排序时排在其它数值前面。换句话说，升序排序时， 空值排在末尾，而降序排序时空值排在开头。
.PP
 字符类型的数据是按照区域相关的字符集顺序排序的，这个区域是在数据库集群初始化的时候建立的。
.SS "LIMIT 子句"
.PP
LIMIT 子句由两个独立的子句组成：
.sp
.nf
LIMIT { \fIcount\fR | ALL }
OFFSET \fIstart\fR
.sp
.fi
 这里 \fIcount\fR 声明返回的最大行数，而 \fIstart\fR 声明开始返回行之前忽略的行数。
 .PP
  LIMIT 允许你检索由查询其他部分生成的行的某一部分。 如果给出了限制计数，那么返回的行数不会超过哪个限制。 如果给出了一个偏移量，那么开始返回行之前会忽略那个数量的行。
.PP
 在使用 LIMIT 时， 一个好习惯是使用一个 ORDER BY 子句把结果行限制成一个唯一的顺序。 否则你会得到无法预料的查询返回的子集 --- 你可能想要第十行到第二十行， 但以什么顺序？除非你声明 ORDER BY，否则你不知道什么顺序。
.PP
 查询优化器在生成查询规划时把 LIMIT 考虑进去了， 所以你很有可能因给出的 LIMIT 和 OFFSET 值不同而得到不同的规划（生成不同的行序）。 因此用不同的 LIMIT/OFFSET 值选择不同的查询结果的子集将不会产生一致的结果， 除非你用 ORDER BY 强制生成一个可预计的结果顺序。 这可不是毛病；这是 SQL 生来的特点，因为除非用了 ORDER BY 约束顺序， SQL 不保证查询生成的结果有任何特定的顺序。
.SS "DISTINCT 子句"
.PP
 如果声明了 DISTINCT，那么就从结果集中删除所有重复的行（每个有重复的组都保留一行）。 ALL 声明相反的作用：所有行都被保留；这个是缺省。
.PP
DISTINCT ON ( \fIexpression\fR [, ...] )
只保留那些在给出的表达式上运算出相同结果的行集合中的第一行。 DISTINCT ON 表达式是使用与 ORDER BY （见上文） 相同的规则进行解释的。请注意，除非我们使用了 ORDER BY 来保证我们需要的行首先出现，否则，每个 "第一行" 是不可预测的。 比如，
.sp
.nf
SELECT DISTINCT ON (location) location, time, report
    FROM weather_reports
    ORDER BY location, time DESC;
.sp
.fi
 为每个地点检索最近的天气报告。但是如果我们没有使用 ORDER BY  来强制对每个地点的时间值进行降序排序，那么我们就会得到每个地点的不知道什么时候的报告。
.PP
 DISTINCT ON 表达式必须匹配最左边的 ORDER BY 表达式。 ORDER BY 子句将通常包含额外的表达式来判断每个 DISTINCT ON 组里面需要的行的优先级。
.SS "FOR UPDATE 子句"
.PP
FOR UPDATE 子句有下面的形式
.sp
.nf
FOR UPDATE [ OF \fItable_name\fR [, ...] ]
.sp
.fi
.PP
FOR UPDATE 令那些被 SELECT 语句检索出来的行被锁住，就像要更新一样。 这样就避免它们在当前事务结束前被其它事务修改或者删除； 也就是说，其它视图 UPDATE，DELETE， 或者 SELECT FOR UPDATE 这些行的事务将被阻塞， 直到当前事务结束。同样，如果一个来自其它事务的 UPDATE， DELETE，或者 SELECT FOR UPDATE  已经锁住了某个或某些选定的行，SELECT FOR UPDATE 将等到那些事务结束， 并且将随后锁住并返回更新的行（或者不返回行，如果行已经被删除）。更多的讨论参阅 Chapter 12 ``Concurrency Control'' 。
.PP
 如果特定的表在 FOR UPDATE 中，那么只有来自这些表中的行才被锁住； 任何在 SELECT 中使用的其它表都只是和平常一样读取。
.PP
FOR UPDATE 不能在那些无法使用独立的表数据行清晰标识返回行的环境里； 比如，它不能和聚集一起使用。
.PP
FOR UPDATE 可以在 LIMIT 前面出现， 主要是为了和 7.3 之前的 PostgreSQL 兼容。 不过，它在 LIMIT 后面执行更高效，因此我们建议放在 LIMIT 后面。
.SH "EXAMPLES 例子"
.PP
 将表 films 和表 distributors 连接在一起：
.sp
.nf
SELECT f.title, f.did, d.name, f.date_prod, f.kind
    FROM distributors d, films f
    WHERE f.did = d.did

       title       | did |     name     | date_prod  |   kind
-------------------+-----+--------------+------------+----------
 The Third Man     | 101 | British Lion | 1949-12-23 | Drama
 The African Queen | 101 | British Lion | 1951-08-11 | Romantic
 ...
.sp
.fi
.PP
 统计用kind 分组的所有电影和组的列/字段的 len（长度）的和：
.sp
.nf
SELECT kind, sum(len) AS total FROM films GROUP BY kind;

   kind   | total
----------+-------
 Action   | 07:34
 Comedy   | 02:58
 Drama    | 14:28
 Musical  | 06:42
 Romantic | 04:38
.sp
.fi
.PP
 统计所有电影（films），组的列/字段 len（长度）的和，用 kind 分组并且显示小于5小时的组总和：
.sp
.nf
SELECT kind, sum(len) AS total
    FROM films
    GROUP BY kind
    HAVING sum(len) < interval '5 hours';

   kind   | total
----------+-------
 Comedy   | 02:58
 Romantic | 04:38
.sp
.fi
.PP
 下面两个例子是根据第二列（name）的内容对单独的结果排序的经典的方法：
.sp
.nf
SELECT * FROM distributors ORDER BY name;
SELECT * FROM distributors ORDER BY 2;

 did |       name
-----+------------------
 109 | 20th Century Fox
 110 | Bavaria Atelier
 101 | British Lion
 107 | Columbia
 102 | Jean Luc Godard
 113 | Luso films
 104 | Mosfilm
 103 | Paramount
 106 | Toho
 105 | United Artists
 111 | Walt Disney
 112 | Warner Bros.
 108 | Westward
.sp
.fi
.PP
 下面这个例子演示如何获得表 distributors 和 actors的连接， 只将每个表中以字母 W 开头的取出来。 因为只取了不相关的行，所以关键字 ALL 被省略了：
.sp
.nf
distributors:               actors:
 did |     name              id |     name
-----+--------------        ----+----------------
 108 | Westward               1 | Woody Allen
 111 | Walt Disney            2 | Warren Beatty
 112 | Warner Bros.           3 | Walter Matthau
 ...                         ...

SELECT distributors.name
    FROM distributors
    WHERE distributors.name LIKE 'W%'
UNION
SELECT actors.name
    FROM actors
    WHERE actors.name LIKE 'W%';

      name
----------------
 Walt Disney
 Walter Matthau
 Warner Bros.
 Warren Beatty
 Westward
 Woody Allen
.sp
.fi
.PP
 这个例子显示了如何在 FROM 子句中使用一个函数， 包括带有和不带字段定义列表的。
.sp
.nf
CREATE FUNCTION distributors(int) RETURNS SETOF distributors AS '
    SELECT * FROM distributors WHERE did = $1;
\' LANGUAGE SQL;

SELECT * FROM distributors(111);
 did |    name
-----+-------------
 111 | Walt Disney

CREATE FUNCTION distributors_2(int) RETURNS SETOF record AS '
    SELECT * FROM distributors WHERE did = $1;
\' LANGUAGE SQL;

SELECT * FROM distributors_2(111) AS (f1 int, f2 text);
 f1  |     f2
-----+-------------
 111 | Walt Disney
.sp
.fi
.SH "COMPATIBILITY 兼容性"
.PP
 当然，SELECT 语句和 SQL 标准兼容。但是还有一些扩展和一些缺少的特性。
.SS "省略 FROM 子句"
.PP
PostgreSQL 允许我们在一个查询里省略 FROM 子句。 它的最直接用途就是计算简单的常量表达式的结果：
.sp
.nf
SELECT 2+2;

 ?column?
----------
        4
.sp
.fi
 其它有些 SQL 数据库不能这么做，除非引入一个单行的伪表做 SELECT 的数据源。
.PP
 这个特性的另外一个不太明显的用途是把一个普通的从一个或多个表的 SELECT 缩写：
.sp
.nf
SELECT distributors.* WHERE distributors.name = 'Westward';

 did |   name
-----+----------
 108 | Westward
.sp
.fi
这样也可以运行是因为我们给 SELECT 中引用了但没有在 FROM 中提到的每个表都加了一个隐含的 FROM 项。
.PP
 尽管这是个很方便的写法，但它却容易误用。 比如，下面的查询
.sp
.nf
SELECT distributors.* FROM distributors d;
.sp
.fi
可能就是个错误；用户最有可能的意思是
.sp
.nf
SELECT d.* FROM distributors d;
.sp
.fi
而不是下面的他实际上得到的无约束的连接
.sp
.nf
SELECT distributors.* FROM distributors d, distributors distributors;
.sp
.fi
为了帮助检测这种错误， PostgreSQL 以及以后的版本将在你使用一条即有隐含 FROM 特性又有明确的 FROM 子句的查询的时候给出警告。
Also, it is possible to disable
the implicit-FROM feature by setting the
ADD_MISSING_FROM parameter to false.
.SS "AS 关键字"
.PP
 在 SQL 标准里，可选的关键字 AS 是多余的，可以忽略掉而不对语句产生任何影响。 PostgreSQL 分析器在重命名列/字段时需要这个关键字， 因为类型扩展的特性会导致在这个环境里的歧义。 不过，AS 在 FROM 项里是可选的。
.SS "GROUP BY 和 ORDER BY 里可用的名字空间"
.PP
 在 SQL92 标准里，ORDER BY 子句只能使用结果字段名或者编号， 而 GROUP BY 子句只能用基于输入字段名的表达式。 PostgreSQL 对这两个子句都进行了扩展， 允许另外一种选择（但是如果存在歧义，则使用标准的解释）。 PostgreSQL 还允许两个子句声明任意的表达式。 请注意在表达式中出现的名字强总是被当作输入字段名，而不是结果字段名。
.PP
SQL99 uses a slightly different definition which is not upward compatible
with SQL92. In most cases, however, PostgreSQL
will interpret an ORDER BY or GROUP
BY expression the same way SQL99 does.
.SS "非标准子句"
.PP
DISTINCT ON,
LIMIT, 和 OFFSET 都没有在 SQL 标准中定义。
.SH "译者"
.B Postgresql 中文网站
.B 何伟平 <laser@pgsqldb.org>
