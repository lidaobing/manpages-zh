. mso zh.tmac
.\" auto-generated by docbook2man-spec $Revision: 1.1 $
.TH "CREATE CONVERSION" "7" "2003-11-02" "SQL - Language Statements" "SQL Commands"
.SH NAME
CREATE CONVERSION \- 定义一个用户定义的码制转换

.SH SYNOPSIS
.sp
.nf
CREATE [DEFAULT] CONVERSION \fIname\fR
    FOR \fIsource_encoding\fR TO \fIdest_encoding\fR FROM \fIfuncname\fR
.sp
.fi
.SH "DESCRIPTION 描述"
.PP
\fBCREATE CONVERSION\fR 定义一种新的编码转换。 转换的名字可以用在 convert 函数内部声明特定的编码转换。 同样，标记为 DEFAULT 的转换可以用于在前端和后端之间的自动编码转换。 出于这个原因，我们必须定义两种转换，从编码 A 到 B 以及从编码 B 到 A。
.PP
 为了可以创建转换，你必须在函数上有EXECUTE权限并且有在目标模式上的CREATE权限。
.SH "PARAMETERS 参数"
.TP
\fBDEFAULT\fR
DEFAULT 子句表示这种转换对于从这种源编码到目的编码的情况是缺省的。在一个模式里每个编码对应该只有一个缺省编码。
.TP
\fB\fIname\fB\fR
 转换的名字。转换名可以用模式修饰。如果没有，那么转换就在当前模式中定义。转换名在一个模式里必须唯一。
.TP
\fB\fIsource_encoding\fB\fR
 源编码名。
.TP
\fB\fIdest_encoding\fB\fR
 目的编码名。
.TP
\fB\fIfuncname\fB\fR
 用于执行转换的函数。这个函数名可以用模式名修饰。 如果没有，那么将从路径中找出这个函数。

 此函数必须有如下的样子：
.sp
.nf
conv_proc(
    integer,  -- 源编码 ID
    integer,  -- 目的编码 ID
    cstring,  -- 源字串（空结尾的 C 字串）
    cstring,  -- 目的字串（空结尾的 C 字串）
    integer   -- 源字串长度
) RETURNS void;
.sp
.fi
.SH "NOTES 注意"
.PP
 使用 DROP CONVERSION 删除用户定义的转换。
.PP
 创建转换所需要的权限可能在未来的版本中改变。
.SH "EXAMPLES 例子"
.PP
 用 myfunc 创建一个从编码 UNICODE 到 LATIN1 的转换：
.sp
.nf
CREATE CONVERSION myconv FOR 'UNICODE' TO 'LATIN1' FROM myfunc;
.sp
.fi
.SH "COMPATIBILITY 兼容性"
.PP
\fBCREATE CONVERSION\fR
是 PostgreSQL 的扩展。 在 SQL 标准里没有CREATE CONVERSION 语句。
.SH "SEE ALSO 参见"
ALTER CONVERSION [\fBalter_conversion\fR(7)], CREATE FUNCTION [\fBcreate_function\fR(l)], DROP CONVERSION [\fBdrop_conversion\fR(l)]
.SH "译者"
.B Postgresql 中文网站
.B 何伟平 <laser@pgsqldb.org>
