. mso zh.tmac
.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.14
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLBOOT 1"
.TH PERLBOOT 7 "2003-11-25" "perl v5.8.3" "Perl Programmers Reference Guide"
.SH "NAME"
perlboot \- 初学者的面向对象教程
.SH "DESCRIPTION 描述"
.IX Header "DESCRIPTION"
如果你对其他语言中的对象并不熟悉的话, 那么其他有关perl对象的文件可能使你感到恐惧, 比如 perlobj , 这是基础性的参考文件, 和 perltoot, 这是介绍perl对象的特性的教程.
.PP
所以, 让我们走另一条路,假定你没有任何关于对象的概念. 你需要了解子程序 (perlsub), 引用 (perlref et. seq.), 和 包(或模块) (perlmod), 如果还不清楚的话,先把他们搞清楚.
.Sh "If we could talk to the animals...如果我们能和动物交谈"
.IX Subsection "If we could talk to the animals..."
让我们让动物讲会儿话:
.PP
.Vb 9
\&    sub Cow::speak {
\&      print "a Cow goes moooo!\en";
\&    }
\&    sub Horse::speak {
\&      print "a Horse goes neigh!\en";
\&    }
\&    sub Sheep::speak {
\&      print "a Sheep goes baaaah!\en"
\&    }
.Ve
.PP
.Vb 3
\&    Cow::speak;
\&    Horse::speak;
\&    Sheep::speak;
.Ve
.PP
结果是:
.PP
.Vb 3
\&    a Cow goes moooo!
\&    a Horse goes neigh!
\&    a Sheep goes baaaah!
.Ve
.PP
没什么特别的. 只是简单的子程序, 虽然来自不同的包, 并用完整的包名来调用. 那么让我们建立一个完整的牧场吧:
.PP
.Vb 5
\&    # Cow::speak, Horse::speak, Sheep::speak 与上同
\&    @pasture = qw(Cow Cow Horse Sheep Sheep);
\&    foreach $animal (@pasture) {
\&      &{$animal."::speak"};
\&    }
.Ve
.PP
结果是:
.PP
.Vb 5
\&    a Cow goes moooo!
\&    a Cow goes moooo!
\&    a Horse goes neigh!
\&    a Sheep goes baaaah!
\&    a Sheep goes baaaah!
.Ve
.PP
嗯. 这里的符号代码引用有些不太好. 我们正依赖于 \f(CW\*(C`no strict subs\*(C'\fR 模式, 在稍大些的程序中应尽量避免. 那为什么要这样呢? 因为我们要调用的子程序和它所在的包似乎是不可分的.
.PP
真的是这样吗?
.Sh "Introducing the method invocation arrow 调用方法时的箭头符号"
.IX Subsection "Introducing the method invocation arrow"
现在,我们说 \f(CW\*(C`Class\->method\*(C'\fR 是调用了包(或模块)\f(CW\*(C`Class\*(C'\fR中的 \&\f(CW\*(C`method\*(C'\fR 方法。(Here, \*(L"Class\*(R" is used in its \*(L"category\*(R" meaning, not its \*(L"scholastic\*(R" meaning.) 不是很准确,不过我们会一步一步的来做. 现在,可以这样做:
.PP
.Vb 4
\&    # Cow::speak, Horse::speak, Sheep::speak as before
\&    Cow->speak;
\&    Horse->speak;
\&    Sheep->speak;
.Ve
.PP
输出为:
.PP
.Vb 3
\&    a Cow goes moooo!
\&    a Horse goes neigh!
\&    a Sheep goes baaaah!
.Ve
.PP
还不是很有趣. 一样的字符,常量,没有变量. 但是, 不同部分可以分开了. 请看:
.PP
.Vb 2
\&    $a = "Cow";
\&    $a->speak; # invokes Cow->speak
.Ve
.PP
哇! 现在包名与子程序名可以分开了, 我们可以用变量来表示包名. 这样,在使用 \f(CW\*(C`use strict refs\*(C'\fR 预编译指令时也可以正常工作了.
.Sh "Invoking a barnyard 创建一个牲口棚"
.IX Subsection "Invoking a barnyard"
现在让我们把箭头用到牲口棚的例子中，范例:
.PP
.Vb 9
\&    sub Cow::speak {
\&      print "a Cow goes moooo!\en";
\&    }
\&    sub Horse::speak {
\&      print "a Horse goes neigh!\en";
\&    }
\&    sub Sheep::speak {
\&      print "a Sheep goes baaaah!\en"
\&    }
.Ve
.PP
.Vb 4
\&    @pasture = qw(Cow Cow Horse Sheep Sheep);
\&    foreach $animal (@pasture) {
\&      $animal->speak;
\&    }
.Ve
.PP
现在我们所有的动物都能说话了, 而且不用使用代码引用.
.PP
不过注意到那些相同的代码. 每个 \f(CW\*(C`speak\*(C'\fR 子程序的结构是相同的: 一个 \f(CW\*(C`print\*(C'\fR 操作符和一个基本相同的字符串，只有两个词不同. 如果我们可以析出相同的部分就更好了，如果将来要把 \f(CW\*(C`goes\*(C'\fR 替换为 \f(CW\*(C`says\*(C'\fR 时就简单得多了
.PP
实际上这并不困难, 不过在这之前我们应该对箭头符号了解的更多一些.
.Sh "The extra parameter of method invocation 方法调用时的额外参数"
.IX Subsection "The extra parameter of method invocation"
语句:
.PP
.Vb 1
\&    Class->method(@args)
.Ve
.PP
这样调用函数 \f(CW\*(C`Class::method\*(C'\fR：
.PP
.Vb 1
\&    Class::method("Class", @args);
.Ve
.PP
(如果子程序找不到,\*(L"继承，inheritance\*(R" 开始起作用,这在后面会讲到). 这意味着我们得到的第一个参数是类名(如果没有给出其他参数，它就是调用时的唯一参数).所以我们可以象这样重写 \f(CW\*(C`Sheep\*(C'\fR speaking 子程序:
.PP
.Vb 4
\&    sub Sheep::speak {
\&      my $class = shift;
\&      print "a $class goes baaaah!\en";
\&    }
.Ve
.PP
另外的动物与此类似:
.PP
.Vb 8
\&    sub Cow::speak {
\&      my $class = shift;
\&      print "a $class goes moooo!\en";
\&    }
\&    sub Horse::speak {
\&      my $class = shift;
\&      print "a $class goes neigh!\en";
\&    }
.Ve
.PP
每次 \f(CW$class\fR  都会得到与子程序相关的正确的值. 但是,还是有很多相似的结构. 可以再简单些吗? 是的. 可以通过在一个类中调用其它的方法来实现.
.Sh "Calling a second method to simplify things 调用另一个方法以简化操作"
.IX Subsection "Calling a second method to simplify things"
我们在 \f(CW\*(C`speak\*(C'\fR 中调用 \f(CW\*(C`sound\*(C'\fR. 这个方法提供声音的内容.
.PP
.Vb 7
\&    { package Cow;
\&      sub sound { "moooo" }
\&      sub speak {
\&        my $class = shift;
\&        print "a $class goes ", $class->sound, "!\en"
\&      }
\&    }
.Ve
.PP
现在, 当我们调用 \f(CW\*(C`Cow\->speak\*(C'\fR 时, 我们在 \f(CW\*(C`speak\*(C'\fR 中得到 \f(CW\*(C`Cow\*(C'\fR 的类 \f(CW$class\fR. 他会选择 \f(CW\*(C`Cow\->sound\*(C'\fR 方法, 然后返回 \f(CW\*(C`moooo\*(C'\fR. 那如果是 \f(CW\*(C`Horse\*(C'\fR 呢?
.PP
.Vb 7
\&    { package Horse;
\&      sub sound { "neigh" }
\&      sub speak {
\&        my $class = shift;
\&        print "a $class goes ", $class->sound, "!\en"
\&      }
\&    }
.Ve
.PP
仅仅包名和声音有变化. 因此我们可以在Cow和Horse中共用 \f(CW\*(C`speak\*(C'\fR 吗? 是的,通过继承实现!
.Sh "Inheriting the windpipes 继承气管"
.IX Subsection "Inheriting the windpipes"
我们创建一个公共函数包,命名为 \f(CW\*(C`Animal\*(C'\fR,在其中定义 \f(CW\*(C`speak\*(C'\fR:
.PP
.Vb 6
\&    { package Animal;
\&      sub speak {
\&        my $class = shift;
\&        print "a $class goes ", $class->sound, "!\en"
\&      }
\&    }
.Ve
.PP
然后,在每个动物那里 \*(L"继承，inherits\*(R" \f(CW\*(C`Animal\*(C'\fR 类, 同时赋予每个动物各自的声音:
.PP
.Vb 4
\&    { package Cow;
\&      @ISA = qw(Animal);
\&      sub sound { "moooo" }
\&    }
.Ve
.PP
注意增加的数组 \f(CW@ISA\fR  . 我们马上讲到它.
.PP
现在当我们调用 \f(CW\*(C`Cow\->speak\*(C'\fR 时会发生什麽?
.PP
首先, Perl构造参数列表. 在这种情况下, 只有 \f(CW\*(C`Cow\*(C'\fR. 然后Perl 查找 \f(CW\*(C`Cow::speak\*(C'\fR. 但是找不到, 所以Perl检查继承数组 \f(CW@Cow::ISA\fR. 找到了, 那里只有一个 \f(CW\*(C`Animal\*(C'\fR
.PP
Perl 然后在 \f(CW\*(C`Animal\*(C'\fR 中查找 \f(CW\*(C`speak\*(C'\fR, \f(CW\*(C`Animal::speak\*(C'\fR. 找到了, 然后调用该子程序, 参数在一开始就被固定了.
.PP
在子程序 \f(CW\*(C`Animal::speak\*(C'\fR 中, \f(CW$class\fR 是 \f(CW\*(C`Cow\*(C'\fR (第一个参数). 在我们调用 \f(CW\*(C`$class\->sound\*(C'\fR 时, 首先寻找 \f(CW\*(C`Cow\->sound\*(C'\fR , 找到了, 因此不用查看 \f(CW@ISA\fR. 成功!
.ie n .Sh "关于@ISA应该注意的几点问题"
.el .Sh "关于\f(CW@ISA\fP应该注意的几点问题"
.IX Subsection "A few notes about @ISA"
神奇的 \f(CW@ISA\fR 变量 (读作 \*(L"is a\*(R" 而不是 \*(L"ice\-uh\*(R"), 声明了 \f(CW\*(C`Cow\*(C'\fR 是一个(\*(L"is a\*(R") \f(CW\*(C`Animal\*(C'\fR。 注意它是一个数组,而不是一个单值, 因为在个别情况下, 需要在几个父类中寻找方法.
.PP
如果 \f(CW\*(C`Animal\*(C'\fR 也有一个 \f(CW@ISA\fR, 我们也要查看它. 寻找是递归的,深度优先,在每个 \f(CW@ISA\fR 中从左到右寻找. 一般地,每个 \f(CW@ISA\fR 只有一个元素(多元素意味着多继承和多重的头痛), 这样我们可以得到一个漂亮的继承树.
.PP
如果使用 \f(CW\*(C`use strict\*(C'\fR, @ISA会引起抱怨, 因为它不是含有显式包名的变量, 也不是字典变量 (\*(L"my\*(R"). 我们不能把它用做\*(L"my\*(R"变量(它必须属于所继承的包),但是也还是有几种解决的办法.
.PP
最简单的办法是加上包名:
.PP
.Vb 1
\&    @Cow::ISA = qw(Animal);
.Ve
.PP
或者使用包声明:
.PP
.Vb 3
\&    package Cow;
\&    use vars qw(@ISA);
\&    @ISA = qw(Animal);
.Ve
.PP
如果你希望把包放到程序内, 可以把:
.PP
.Vb 4
\&    package Cow;
\&    use Animal;
\&    use vars qw(@ISA);
\&    @ISA = qw(Animal);
.Ve
.PP
简写为:
.PP
.Vb 2
\&    package Cow;
\&    use base qw(Animal);
.Ve
.PP
这就精简多了.
.Sh "Overriding the methods 方法重载"
.IX Subsection "Overriding the methods"
让我们添上一只老鼠, 它的声音差不多听不到:
.PP
.Vb 10
\&    # Animal package from before
\&    { package Mouse;
\&      @ISA = qw(Animal);
\&      sub sound { "squeak" }
\&      sub speak {
\&        my $class = shift;
\&        print "a $class goes ", $class->sound, "!\en";
\&        print "[but you can barely hear it!]\en";
\&      }
\&    }
.Ve
.PP
.Vb 1
\&    Mouse->speak;
.Ve
.PP
输出为:
.PP
.Vb 2
\&    a Mouse goes squeak!
\&    [but you can barely hear it!]
.Ve
.PP
在这里, \f(CW\*(C`Mouse\*(C'\fR 有它自己的speak 函数, 所以 \f(CW\*(C`Mouse\->speak\*(C'\fR 不会调用\f(CW\*(C`Animal\->speak\*(C'\fR. 这叫做重载 \*(L"overriding\*(R". 实际上, 我们甚至不用说\f(CW\*(C`Mouse\*(C'\fR 是 \f(CW\*(C`Animal\*(C'\fR, 因为 \f(CW\*(C`speak\*(C'\fR 所用到的所有方法在 \f(CW\*(C`Mouse\*(C'\fR 中都有定义.
.PP
但是有些代码与 \f(CW\*(C`Animal\->speak\*(C'\fR 的相同 , 这在程序维护时是个问题. 我们能不能让 \f(CW\*(C`Mouse\*(C'\fR 与其它 \f(CW\*(C`Animal\*(C'\fR 作相同的事,但是给它加上特殊的部分呢? 可以!
.PP
首先,我们可以直接调用 \f(CW\*(C`Animal::speak\*(C'\fR 方法:
.PP
.Vb 10
\&    # Animal package from before
\&    { package Mouse;
\&      @ISA = qw(Animal);
\&      sub sound { "squeak" }
\&      sub speak {
\&        my $class = shift;
\&        Animal::speak($class);
\&        print "[but you can barely hear it!]\en";
\&      }
\&    }
.Ve
.PP
注意我们必须使用 \f(CW$class\fR (几乎肯定是\f(CW"Mouse"\fR) 作为 \f(CW\*(C`Animal::speak\*(C'\fR 的第一个参数, 因为我们没有用箭头符号. 那为什么不用呢? 嗯, 如果我们在那儿调用 \f(CW\*(C`Animal\->speak\*(C'\fR, 则第一个参数是 \f(CW"Animal"\fR 而不是 \f(CW"Mouse"\fR , 这样当调用 \f(CW\*(C`sound\*(C'\fR 时, 就找不到正确的函数了.
.PP
虽然如此,直接调用 \f(CW\*(C`Animal::speak\*(C'\fR 确实不怎么好. 万一 \f(CW\*(C`Animal::speak\*(C'\fR 不存在, 而是继承自 \f(CW@Animal::ISA\fR 中的某个类呢? 因为没有使用箭头符号, 我们只有一次机会去调用正确的函数.
.PP
还要注意到,现在类名 \f(CW\*(C`Animal\*(C'\fR 直接在子程序中使用. 如果维护代码的人没有注意到这一点, 改变了 <Mouse> 的 \f(CW@ISA\fR，没有注意到 \f(CW\*(C`speak\*(C'\fR 用到了 \f(CW\*(C`Animal\*(C'\fR 那就会出问题. 因此, 这可能不是一个好方法.
.Sh "Starting the search from a different place 从其它地方开始寻找"
.IX Subsection "Starting the search from a different place"
较好的解决办法是让Perl从继承链的上一级开始寻找:
.PP
.Vb 9
\&    # same Animal as before
\&    { package Mouse;
\&      # same @ISA, &sound as before
\&      sub speak {
\&        my $class = shift;
\&        $class->Animal::speak;
\&        print "[but you can barely hear it!]\en";
\&      }
\&    }
.Ve
.PP
这就对了. 使用这一语法, 我们从 \f(CW\*(C`Animal\*(C'\fR 寻找 \f(CW\*(C`speak\*(C'\fR, 在找不到时寻找 \f(CW\*(C`Animal\*(C'\fR 的继承链.且第一个参数是 \f(CW$class\fR, 所以 \f(CW\*(C`speak\*(C'\fR 和\f(CW\*(C`Mouse::sound\*(C'\fR 都会被正确地调用.
.PP
但这还不是最好的方法.我们还必须调整 \f(CW@ISA\fR 的元素顺序. 更糟糕的是, 如果 \f(CW\*(C`Mouse\*(C'\fR 有多个父类在 \f(CW@ISA\fR, 我们还要知道哪个类定义了 \f(CW\*(C`speak\*(C'\fR. 那么,有没有更好的办法呢?
.Sh "The \s-1SUPER\s0 way of doing things 使用SUPER方法"
.IX Subsection "The SUPER way of doing things"
通过把 \f(CW\*(C`Animal\*(C'\fR 改成 \f(CW\*(C`SUPER\*(C'\fR 类, 程序可以自动在所有父类中(\f(CW@ISA\fR):
.PP
.Vb 9
\&    # same Animal as before
\&    { package Mouse;
\&      # same @ISA, &sound as before
\&      sub speak {
\&        my $class = shift;
\&        $class->SUPER::speak;
\&        print "[but you can barely hear it!]\en";
\&      }
\&    }
.Ve
.PP
\f(CW\*(C`SUPER::speak\*(C'\fR 意味着在当前包的 \f(CW@ISA\fR 中寻找 \f(CW\*(C`speak\*(C'\fR, 调用第一个找到的函数。注意它不会查找 \f(CW$class\fR 的 \f(CW@ISA\fR
.Sh "Where we're at so far...到现在为止我们学了些什麽"
.IX Subsection "Where we're at so far..."
我们已经看到了箭头符号语法:
.PP
.Vb 1
\&  Class->method(@args);
.Ve
.PP
和它的等价形式:
.PP
.Vb 2
\&  $a = "Class";
\&  $a->method(@args);
.Ve
.PP
它们构造这样一个参数列表:
.PP
.Vb 1
\&  ("Class", @args)
.Ve
.PP
并调用
.PP
.Vb 1
\&  Class::method("Class", @Args);
.Ve
.PP
但是，如果找不到 \f(CW\*(C`Class::method\*(C'\fR, 程序会查看 \f(CW@Class::ISA\fR (递归的) 找到一个包含 \f(CW\*(C`method\*(C'\fR 的包,然后执行它.
.PP
使用这种简单的语法, 我们可以有类方法,(多)继承,重载,以及其它扩展. 使用我们已经学到的东西, 我们可以析出公共的代码,以各种不同的形式重用同一工具. 这是对象能够提供的核心内容, 但是对象还能够提供实例数据, 这一点我们还没有涉及.
.Sh "A horse is a horse, of course of course \*(-- or is it? 马就是马——真的是这样吗?"
.IX Subsection "A horse is a horse, of course of course  or is it?"
我们从 \f(CW\*(C`Animal\*(C'\fR 和 \f(CW\*(C`Horse\*(C'\fR 类的代码开始:
.PP
.Vb 10
\&  { package Animal;
\&    sub speak {
\&      my $class = shift;
\&      print "a $class goes ", $class->sound, "!\en"
\&    }
\&  }
\&  { package Horse;
\&    @ISA = qw(Animal);
\&    sub sound { "neigh" }
\&  }
.Ve
.PP
这样使得我们调用 \f(CW\*(C`Horse\->speak\*(C'\fR，从而向上调用 \f(CW\*(C`Animal::speak\*(C'\fR，然后调用 \f(CW\*(C`Horse::sound\*(C'\fR 来获得指定的声音，输出为:
.PP
.Vb 1
\&  a Horse goes neigh!
.Ve
.PP
但是我们所有的马都是相同的. 如果我增加一个子程序, 所有的马都会共享它. 这在创建相同的马时确实不错, 但是我们如何能够区分不同的马呢? 比如, 假设我想给我的第一匹马起个名字. 应该有办法使得它的名字和别的马的名字不同.
.PP
这可以通过创建一个 \*(L"实例,instance\*(R" 来实现. 实例是由类创建的. 在Perl中, 任何引用都可以是实例, 就让我们从最简单的引用开始吧,一个标量引用:
.PP
.Vb 2
\&  my $name = "Mr. Ed";
\&  my $talking = \e$name;
.Ve
.PP
现在 \f(CW$talking\fR 是指向实例特有数据( \f(CW$name\fR )的引用。把这个引用变成真正的实例的是一个特殊的操作符,叫做 \f(CW\*(C`bless\*(C'\fR:
.PP
.Vb 1
\&  bless $talking, Horse;
.Ve
.PP
这个操作符把包名 \f(CW\*(C`Horse\*(C'\fR 中的所有信息存放到引用所指向的东西中. 这时,我们说 \f(CW$talking\fR 是 \f(CW\*(C`Horse\*(C'\fR 的一个实例 . 也就是说, 它是一匹独特的马. 引用并没有改变, 还可以用于间接引用操作符.
.Sh "Invoking an instance method 调用实例方法"
.IX Subsection "Invoking an instance method"
箭头符号可以用于实例. 那么, 听听 \f(CW$talking\fR 的声音吧:
.PP
.Vb 1
\&  my $noise = $talking->sound;
.Ve
.PP
要调用 \f(CW\*(C`sound\*(C'\fR, Perl 首先注意到 \f(CW$talking\fR 是一个 blessed 引用 (因此是一个实例). 它会构造一个参数列表, 现在只有 \f(CW$talking\fR. (在后面我们会看到参数们在实例变量之后, 与使用类时相似.)
.PP
然后,是真正有意思的部分: Perl 查找实例所属的类, 这里是 \f(CW\*(C`Horse\*(C'\fR, 在其中寻找对应的方法. 这里, \f(CW\*(C`Horse::sound\*(C'\fR 直接可以找到(不用使用继承), 最后这样调用:
.PP
.Vb 1
\&  Horse::sound($talking)
.Ve
.PP
注意这里的第一个参数还是实例本身, 而不像前面我们学到的是类名. 最后返回值是 \f(CW\*(C`neigh\*(C'\fR, 它被赋值给 \f(CW$noise\fR 变量.
.PP
如果找不到 Horse::sound, 会在 \f(CW@Horse::ISA\fR 列表中查找. 类方法与实例方法的唯一区别是调用时的第一个参数是实例(一个blessed引用)还是一个类名(一个字符串).
.Sh "Accessing the instance data 访问实例数据"
.IX Subsection "Accessing the instance data"
因为我们得到的第一个参数是实例,我们可以访问实例特有的数据. 我们可以取得马的名字:
.PP
.Vb 8
\&  { package Horse;
\&    @ISA = qw(Animal);
\&    sub sound { "neigh" }
\&    sub name {
\&      my $self = shift;
\&      $$self;
\&    }
\&  }
.Ve
.PP
现在,我们调用名字:
.PP
.Vb 1
\&  print $talking->name, " says ", $talking->sound, "\en";
.Ve
.PP
在 \f(CW\*(C`Horse::name\*(C'\fR 中, \f(CW@_\fR 数组仅含有 \f(CW$talking\fR, shift 将 \f(CW$talking\fR 赋给了 \f(CW$self\fR. (传统上我们在处理实例方法时总是把第一个元素赋给 \f(CW$self\fR, 所以你也应该这么做, 除非你有不这样做的充分理由.) 然后, \f(CW$self\fR 被标量化,成为 \f(CW\*(C`Mr. Ed\*(C'\fR, 这就行了. 输出是:
.PP
.Vb 1
\&  Mr. Ed says neigh.
.Ve
.Sh "How to build a horse 如何创建一匹马"
.IX Subsection "How to build a horse"
当然啦,如果我们手工创建所有的马, 我们会出很多错误. 不仅如此,我们还亵渎了面向对象编程的特性,因为在那种情况下马的"内脏"也可见了. 如果你是兽医的话,这倒正好, 可是如果你仅仅是个爱马者呢? 所以,我们让 Horse 类来创建一匹新马:
.PP
.Vb 13
\&  { package Horse;
\&    @ISA = qw(Animal);
\&    sub sound { "neigh" }
\&    sub name {
\&      my $self = shift;
\&      $$self;
\&    }
\&    sub named {
\&      my $class = shift;
\&      my $name = shift;
\&      bless \e$name, $class;
\&    }
\&  }
.Ve
.PP
现在,我们可以用 \f(CW\*(C`named\*(C'\fR 方法创建一匹马:
.PP
.Vb 1
\&  my $talking = Horse->named("Mr. Ed");
.Ve
.PP
注意到我们有回到了类方法, 所以传递给 \f(CW\*(C`Horse::named\*(C'\fR 的两个参数是 \f(CW\*(C`Horse\*(C'\fR 和 \f(CW\*(C`Mr. Ed\*(C'\fR. \*(C`bless\*(C'\fR 操作符不仅将 \f(CW$name\fR 实例化, 且将指向 \f(CW$name\fR 的引用作为返回值返回. 这样, 我们就创建了一匹马.
.PP
这里,我们调用了构造器 \f(CW\*(C`named\*(C'\fR, 它的参数就是特定的 \f(CW\*(C`Horse\*(C'\fR 的名字. 你可以使用不同的构造器用不同的名字建立不同的对象(比如记录它的谱系或生日). 但是, 你会发现多数使用Perl的人更喜欢把构造器命名为 \f(CW\*(C`new\*(C'\fR, 并使用不同的方法解释 \f(CW\*(C`new\*(C'\fR 的参数. 两种都挺好,只要你能创建对象就行. (你会自己创建一个,对吗?)
.Sh "Inheriting the constructor 继承构造器"
.IX Subsection "Inheriting the constructor"
但是那个方法中有没有什麽对于 \f(CW\*(C`Horse\*(C'\fR 来说比较特殊的东西呢? 没有. 因此, 从 \f(CW\*(C`Animal\*(C'\fR 创建其它任何东西也可以使用相同的方法,我们来试试::
.PP
.Vb 19
\&  { package Animal;
\&    sub speak {
\&      my $class = shift;
\&      print "a $class goes ", $class->sound, "!\en"
\&    }
\&    sub name {
\&      my $self = shift;
\&      $$self;
\&    }
\&    sub named {
\&      my $class = shift;
\&      my $name = shift;
\&      bless \e$name, $class;
\&    }
\&  }
\&  { package Horse;
\&    @ISA = qw(Animal);
\&    sub sound { "neigh" }
\&  }
.Ve
.PP
好了, 但是以实例调用 \f(CW\*(C`speak\*(C'\fR 会产生什麽结果呢?
.PP
.Vb 2
\&  my $talking = Horse->named("Mr. Ed");
\&  $talking->speak;
.Ve
.PP
我们得到的是:
.PP
.Vb 1
\&  a Horse=SCALAR(0xaca42ac) goes neigh!
.Ve
.PP
为什麽?因为 \f(CW\*(C`Animal::speak\*(C'\fR 希望它的第一个参数是类名, 而不是实例. 当实例被传入时,我们希望使用的是字符串而不是实例本身,显示的结果不是我们所希望的.
.Sh "Making a method work with either classes or instances 使方法同时支持类和实例"
.IX Subsection "Making a method work with either classes or instances"
我们需要做的是让方法检测它是被实例调用的还是被类调用的. 最直接的方法是使用 \f(CW\*(C`ref\*(C'\fR 操作符. 它在参数是实例时返回字符串,在参数是类名时返回 \f(CW\*(C`undef\*(C'\fR. 我们首先改写 \f(CW\*(C`name\*(C'\fR 方法:
.PP
.Vb 6
\&  sub name {
\&    my $either = shift;
\&    ref $either
\&      ? $$either # it's an instance, return name
\&      : "an unnamed $either"; # it's a class, return generic
\&  }
.Ve
.PP
在这儿, \f(CW\*(C`?:\*(C'\fR 操作符决定是选择间接引用(dereference)还是派生字符串. 现在我们可以同时使用类或实例了. 注意我修改了第一个参数为 \f(CW$either\fR 来表示期望的变化:
.PP
.Vb 3
\&  my $talking = Horse->named("Mr. Ed");
\&  print Horse->name, "\en"; # prints "an unnamed Horse\en"
\&  print $talking->name, "\en"; # prints "Mr Ed.\en"
.Ve
.PP
我们可以改写 \f(CW\*(C`speak\*(C'\fR :
.PP
.Vb 4
\&  sub speak {
\&    my $either = shift;
\&    print $either->name, " goes ", $either->sound, "\en";
\&  }
.Ve
.PP
而 \f(CW\*(C`sound\*(C'\fR 本来就可以工作. 那么现在就一切完成了!
.Sh "Adding parameters to a method 给方法加参数"
.IX Subsection "Adding parameters to a method"
让我们训练动物们吃饭:
.PP
.Vb 30
\&  { package Animal;
\&    sub named {
\&      my $class = shift;
\&      my $name = shift;
\&      bless \e$name, $class;
\&    }
\&    sub name {
\&      my $either = shift;
\&      ref $either
\&        ? $$either # it's an instance, return name
\&        : "an unnamed $either"; # it's a class, return generic
\&    }
\&    sub speak {
\&      my $either = shift;
\&      print $either->name, " goes ", $either->sound, "\en";
\&    }
\&    sub eat {
\&      my $either = shift;
\&      my $food = shift;
\&      print $either->name, " eats $food.\en";
\&    }
\&  }
\&  { package Horse;
\&    @ISA = qw(Animal);
\&    sub sound { "neigh" }
\&  }
\&  { package Sheep;
\&    @ISA = qw(Animal);
\&    sub sound { "baaaah" }
\&  }
.Ve
.PP
试试吧:
.PP
.Vb 3
\&  my $talking = Horse->named("Mr. Ed");
\&  $talking->eat("hay");
\&  Sheep->eat("grass");
.Ve
.PP
输出为:
.PP
.Vb 2
\&  Mr. Ed eats hay.
\&  an unnamed Sheep eats grass.
.Ve
.PP
有参数的实例方法调用时首先得到实例的引用，然后得到参数的列表。因此第一个调用实际上是这样的:
.PP
.Vb 1
\&  Animal::eat($talking, "hay");
.Ve
.Sh "More interesting instances 更多有趣的实例"
.IX Subsection "More interesting instances"
如果实例需要更多的数据该怎么办呢? 更多的项目产生更有趣的实例, 每个项目可以是一个引用或者甚至是一个对象. 最简单的方法是把它们存放到哈希中. 哈希中的关键词叫做'实例变量"(instance variables)或者"成员变量"(member variables)，相应的值也就是变量的值。
.PP
但是我们怎么把马放到哈希中呢? 回忆到对象是被实例化(blessed)的引用. 我们可以简单地创建一个祝福了的哈希引用,同时相关的的内容也作些修改就可以了.
.PP
让我们创建一只有名字有颜色的绵羊：
.PP
.Vb 1
\&  my $bad = bless { Name => "Evil", Color => "black" }, Sheep;
.Ve
.PP
那么 \f(CW\*(C`$bad\->{Name}\*(C'\fR 是 \f(CW\*(C`Evil\*(C'\fR, \f(CW\*(C`$bad\->{Color}\*(C'\fR 是 \f(CW\*(C`black\*(C'\fR. 但是我们想通过 \f(CW\*(C`$bad\->name\*(C'\fR 存取绵羊的名字name, 这有点的问题,因为现在它期望一个标量引用. 别担心,因为修正它很简单:
.PP
.Vb 7
\&  ## in Animal
\&  sub name {
\&    my $either = shift;
\&    ref $either ?
\&      $either->{Name} :
\&      "an unnamed $either";
\&  }
.Ve
.PP
\f(CW\*(C`named\*(C'\fR 当然还是创建标量的绵羊, 如下修正就好了:
.PP
.Vb 7
\&  ## in Animal
\&  sub named {
\&    my $class = shift;
\&    my $name = shift;
\&    my $self = { Name => $name, Color => $class->default_color };
\&    bless $self, $class;
\&  }
.Ve
.PP
默认颜色 \f(CW\*(C`default_color\*(C'\fR 是什麽? 嗯, 如果 \f(CW\*(C`named\*(C'\fR 只有一个参数name, 我们还是希望有个颜色, 所以我们设定一个类初始化颜色. 对绵羊来说, 白色比较好:
.PP
.Vb 2
\&  ## in Sheep
\&  sub default_color { "white" }
.Ve
.PP
为了避免为每个类定义颜色, 我们可以在 \f(CW\*(C`Animal\*(C'\fR 中定义一个 \*(L"缺省的缺省，backstop\*(R" 的颜色:
.PP
.Vb 2
\&  ## in Animal
\&  sub default_color { "brown" }
.Ve
.PP
现在, 因为只有 \f(CW\*(C`name\*(C'\fR 和 \f(CW\*(C`named\*(C'\fR 与对象的 \*(L"结构，structure\*(R" 相关, 其余的部分可以保持不变, 所以 \f(CW\*(C`speak\*(C'\fR 工作正常.
.Sh "A horse of a different color 一匹不同颜色的马"
.IX Subsection "A horse of a different color"
但是如果所有的马都是棕色的,也挺烦人的. 所以我们可以写个方法来改变马的颜色.
.PP
.Vb 7
\&  ## in Animal
\&  sub color {
\&    $_[0]->{Color}
\&  }
\&  sub set_color {
\&    $_[0]->{Color} = $_[1];
\&  }
.Ve
.PP
注意到存取参数的不同方法了吗: \f(CW$_[0]\fR 直接使用, 而没有用 \f(CW\*(C`shift\*(C'\fR. (这在我们频繁存取时可以节省一些时间.) 现在我们可以把Mr. Ed的颜色变过来:
.PP
.Vb 3
\&  my $talking = Horse->named("Mr. Ed");
\&  $talking->set_color("black-and-white");
\&  print $talking->name, " is colored ", $talking->color, "\en";
.Ve
.PP
结果是:
.PP
.Vb 1
\&  Mr. Ed is colored black-and-white
.Ve
.Sh "Summary 总结"
.IX Subsection "Summary"
现在我们讲了类方法,构造器,实例方法,实例数据,甚至还有存取器(accessor). 但是这些还仅仅是开始. 我们还没有讲到以两个函数 getters,setters 形式出现的存取器，析构器(destructor),间接对象(indirect object notation),子类(subclasses that add instance data),per-class data,重载(overloading),\*(L"isa\*(R" 和 \*(L"can\*(R" 测试,公共类(\f(CW\*(C`UNIVERSAL\*(C'\fR class),等等. 这有待其它文档去讲解了. 无论如何,希望本文使你对对象有所了解.
.SH "SEE ALSO 参见"
.IX Header "SEE ALSO"
更多信息可参见 perlobj (这里有更多的Perl对象的细节,而本文的是基础), perltoot (面向对象的中级教程),  perlbot  (更多的技巧), 以及书籍,比如Damian Conway的不错的书叫做《面向对象的Perl (\fIObject Oriented Perl\fR)》。
.PP
某些模块可能对你有用，它们是 Class::Accessor,
Class::Class, Class::Contract, Class::Data::Inheritable,
Class::MethodMaker 还有 Tie::SecureHash
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 1999, 2000 by Randal L. Schwartz and Stonehenge
Consulting Services, Inc.  Permission is hereby granted to distribute
this document intact with the Perl distribution, and in accordance
with the licenses of the Perl distribution; derived documents must
include this copyright notice intact.
.PP
Portions of this text have been derived from Perl Training materials
originally appearing in the \fIPackages, References, Objects, and
Modules\fR course taught by instructors for Stonehenge Consulting
Services, Inc. and used with permission.
.PP
Portions of this text have been derived from materials originally
appearing in \fILinux Magazine\fR and used with permission.
.SH "中文版维护人"
.B redcandle <redcandle51@chinaren.com>
.SH "中文版最新更新"
.B 2001年12月9日星期日
.SH "中文手册页翻译计划"
.B http://cmpp.linuxforum.net
